From b91e8d8e2cd51b396d732f309866c7bb900f0f33 Mon Sep 17 00:00:00 2001
From: Zhi Yuan Wan <dv.xw@qq.com>
Date: Sat, 2 Aug 2014 10:43:00 +0800
Subject: [PATCH 1/5] Added yuq NAND MTD driver

Conflicts:
	boards.cfg
	drivers/dma/Makefile
	include/configs/sunxi-common.h

make bootscript works.

Conflicts:
	boards.cfg
	include/configs/sunxi-common.h

Rudely fixed the float problem....

Conflicts:
	include/configs/sunxi-common.h

Added partition comment and cmd_nand usage

Conflicts:
	include/configs/sunxi-common.h

cherry picking fix
---
 arch/arm/cpu/armv7/sunxi/clock.c              |   4 +-
 arch/arm/cpu/armv7/sunxi/clock_sun4i.c        |  31 ++
 arch/arm/include/asm/arch-sunxi/clock.h       |   3 +
 arch/arm/include/asm/arch-sunxi/clock_sun4i.h |   2 +
 arch/arm/include/asm/arch-sunxi/dma.h         | 265 +++++++++++
 arch/arm/include/asm/arch-sunxi/dma_i.h       | 127 ++++++
 common/cmd_nand.c                             | 171 ++++++++
 common/spl/spl_nand.c                         | 109 ++++-
 drivers/dma/Makefile                          |   1 +
 drivers/dma/sunxi_dma.c                       | 327 ++++++++++++++
 drivers/mtd/nand/Makefile                     |   8 +
 drivers/mtd/nand/sunxi_nand.c                 | 610 ++++++++++++++++++++++++++
 drivers/mtd/nand/sunxi_nand.h                 | 206 +++++++++
 drivers/mtd/nand/sunxi_nand1k.c               |  91 ++++
 drivers/mtd/nand/sunxi_nand_common.c          | 257 +++++++++++
 drivers/mtd/nand/sunxi_nand_id.c              | 278 ++++++++++++
 drivers/mtd/nand/sunxi_nand_spl.c             | 288 ++++++++++++
 include/configs/sunxi-common.h                |  46 +-
 18 files changed, 2814 insertions(+), 10 deletions(-)
 create mode 100644 arch/arm/include/asm/arch-sunxi/dma.h
 create mode 100644 arch/arm/include/asm/arch-sunxi/dma_i.h
 create mode 100644 drivers/dma/sunxi_dma.c
 create mode 100644 drivers/mtd/nand/sunxi_nand.c
 create mode 100644 drivers/mtd/nand/sunxi_nand.h
 create mode 100644 drivers/mtd/nand/sunxi_nand1k.c
 create mode 100644 drivers/mtd/nand/sunxi_nand_common.c
 create mode 100644 drivers/mtd/nand/sunxi_nand_id.c
 create mode 100644 drivers/mtd/nand/sunxi_nand_spl.c

diff --git a/arch/arm/cpu/armv7/sunxi/clock.c b/arch/arm/cpu/armv7/sunxi/clock.c
index 47fb70f..0de3c78 100644
--- a/arch/arm/cpu/armv7/sunxi/clock.c
+++ b/arch/arm/cpu/armv7/sunxi/clock.c
@@ -20,6 +20,8 @@ int clock_init(void)
 	clock_init_safe();
 #endif
 	clock_init_uart();
-
+#ifdef CONFIG_NAND_SUNXI
+	clock_init_nand();
+#endif
 	return 0;
 }
diff --git a/arch/arm/cpu/armv7/sunxi/clock_sun4i.c b/arch/arm/cpu/armv7/sunxi/clock_sun4i.c
index b8b16cf..b81e368 100644
--- a/arch/arm/cpu/armv7/sunxi/clock_sun4i.c
+++ b/arch/arm/cpu/armv7/sunxi/clock_sun4i.c
@@ -58,6 +58,22 @@ void clock_init_uart(void)
 		CLK_GATE_OPEN << (APB1_GATE_UART_SHIFT+CONFIG_CONS_INDEX-1));
 }
 
+#ifdef CONFIG_NAND_SUNXI
+void clock_init_nand()
+{
+	struct sunxi_ccm_reg *const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	/* nand clock source is osc24m */
+	sr32(&ccm->nand_sclk_cfg, 24, 2, NAND_CLK_SRC_OSC24);
+	sr32(&ccm->nand_sclk_cfg, 16, 2, NAND_CLK_DIV_N);
+	sr32(&ccm->nand_sclk_cfg, 0, 4, NAND_CLK_DIV_M);
+	sr32(&ccm->nand_sclk_cfg, 31, 1, CLK_GATE_OPEN);
+	/* open clock for nand */
+	sr32(&ccm->ahb_gate0, AHB_GATE_OFFSET_NAND, 1, CLK_GATE_OPEN);
+	
+}
+#endif
+
 int clock_twi_onoff(int port, int state)
 {
 	struct sunxi_ccm_reg *const ccm =
@@ -185,3 +201,18 @@ unsigned int clock_get_pll6(void)
 	int k = ((rval & CCM_PLL6_CTRL_K_MASK) >> CCM_PLL6_CTRL_K_SHIFT) + 1;
 	return 24000000 * n * k / 2;
 }
+
+
+/* Return PLL5 frequency in Hz
+ * Note: Assumes PLL5 reference is 24MHz clock
+ */
+unsigned int clock_get_pll5(void)
+{
+	struct sunxi_ccm_reg *const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	uint32_t rval = readl(&ccm->pll5_cfg);
+	int n = (rval >> 8) & 0x1f;
+	int k = ((rval >> 4) & 3) + 1;
+	int p = 1 << ((rval >> 16) & 3);
+	return 24000000 * n * k / p;
+}
diff --git a/arch/arm/include/asm/arch-sunxi/clock.h b/arch/arm/include/asm/arch-sunxi/clock.h
index 5669f39..226e14c 100644
--- a/arch/arm/include/asm/arch-sunxi/clock.h
+++ b/arch/arm/include/asm/arch-sunxi/clock.h
@@ -24,6 +24,9 @@ void clock_set_pll1(unsigned int hz);
 unsigned int clock_get_pll6(void);
 void clock_init_safe(void);
 void clock_init_uart(void);
+#ifdef CONFIG_NAND_SUNXI
+void clock_init_nand(void);
+#endif
 #endif
 
 #endif /* _SUNXI_CLOCK_H */
diff --git a/arch/arm/include/asm/arch-sunxi/clock_sun4i.h b/arch/arm/include/asm/arch-sunxi/clock_sun4i.h
index 928f3f2..1071457 100644
--- a/arch/arm/include/asm/arch-sunxi/clock_sun4i.h
+++ b/arch/arm/include/asm/arch-sunxi/clock_sun4i.h
@@ -253,4 +253,6 @@ struct sunxi_ccm_reg {
 #define CCM_GMAC_CTRL_GPIT_MII (0x0 << 2)
 #define CCM_GMAC_CTRL_GPIT_RGMII (0x1 << 2)
 
+unsigned int clock_get_pll5(void);
+
 #endif /* _SUNXI_CLOCK_SUN4I_H */
diff --git a/arch/arm/include/asm/arch-sunxi/dma.h b/arch/arm/include/asm/arch-sunxi/dma.h
new file mode 100644
index 0000000..0d5db1d
--- /dev/null
+++ b/arch/arm/include/asm/arch-sunxi/dma.h
@@ -0,0 +1,265 @@
+/*
+**********************************************************************************************************************
+*											        eGon
+*						           the Embedded GO-ON Bootloader System
+*									       eGON arm driver sub-system
+*
+*						  Copyright(C), 2006-2010, SoftWinners Microelectronic Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    : wboot_dma
+*
+* By      : Jerry
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#ifndef	_DMA_H_
+#define	_DMA_H_
+
+#define  DMA_HDLER_TYPE_CNT                     2
+#define  DMAC_DMATYPE_NORMAL         			0
+#define  DMAC_DMATYPE_DEDICATED      			1
+
+
+#define  DMA_TRANSFER_HALF_INT       0
+#define  DMA_TRANSFER_END_INT        1
+
+#define  DMA_TRANSFER_UNLOOP_MODE   0
+#define  DMA_TRANSFER_LOOP_MODE     1
+
+
+//================================
+//======    DMA ÅäÖÃ     =========
+//================================
+
+/* DMA »ù´¡ÅäÖÃ  */
+#define DMAC_CFG_CONTINUOUS_ENABLE              (0x01)	//(0x01<<29)
+#define DMAC_CFG_CONTINUOUS_DISABLE             (0x00)	//(0x01<<29)
+
+//* DMA Ê±ÖÓ */
+#define	DMAC_CFG_WAIT_1_DMA_CLOCK				(0x00)	//(0x00<<26)
+#define	DMAC_CFG_WAIT_2_DMA_CLOCK				(0x01)	//(0x01<<26)
+#define	DMAC_CFG_WAIT_3_DMA_CLOCK				(0x02)	//(0x02<<26)
+#define	DMAC_CFG_WAIT_4_DMA_CLOCK				(0x03)	//(0x03<<26)
+#define	DMAC_CFG_WAIT_5_DMA_CLOCK				(0x04)	//(0x04<<26)
+#define	DMAC_CFG_WAIT_6_DMA_CLOCK				(0x05)	//(0x05<<26)
+#define	DMAC_CFG_WAIT_7_DMA_CLOCK				(0x06)	//(0x06<<26)
+#define	DMAC_CFG_WAIT_8_DMA_CLOCK				(0x07)	//(0x07<<26)
+
+/* DMA ´«ÊäÄ¿µÄ¶Ë ÅäÖÃ */
+/* DMA Ä¿µÄ¶Ë ´«Êä¿í¶È */
+#define	DMAC_CFG_DEST_DATA_WIDTH_8BIT			(0x00)	//(0x00<<24)
+#define	DMAC_CFG_DEST_DATA_WIDTH_16BIT			(0x01)	//(0x01<<24)
+#define	DMAC_CFG_DEST_DATA_WIDTH_32BIT			(0x02)	//(0x02<<24)
+
+/* DMA Ä¿µÄ¶Ë Í»·¢´«ÊäÄ£Ê½ */
+#define	DMAC_CFG_DEST_1_BURST       			(0x00)	//(0x00<<23)
+#define	DMAC_CFG_DEST_4_BURST		    		(0x01)	//(0x01<<23)
+
+/* DMA Ä¿µÄ¶Ë µØÖ·±ä»¯Ä£Ê½ */
+#define	DMAC_CFG_DEST_ADDR_TYPE_LINEAR_MODE		(0x00)	//(0x00<<21)
+#define	DMAC_CFG_DEST_ADDR_TYPE_IO_MODE 		(0x01)	//(0x01<<21)
+#define	DMAC_CFG_DEST_ADDR_TYPE_HPAGE_MODE 		(0x02)	//(0x02<<21)
+#define	DMAC_CFG_DEST_ADDR_TYPE_VPAGE_MODE 		(0x03)	//(0x03<<21)
+
+
+/* DMA ´«ÊäÔ´¶Ë ÅäÖÃ */
+/* DMA Ô´¶Ë ´«Êä¿í¶È */
+#define	DMAC_CFG_SRC_DATA_WIDTH_8BIT			(0x00)	//(0x00<<8)
+#define	DMAC_CFG_SRC_DATA_WIDTH_16BIT			(0x01)	//(0x01<<8)
+#define	DMAC_CFG_SRC_DATA_WIDTH_32BIT			(0x02)	//(0x02<<8)
+
+/* DMA Ô´¶Ë Í»·¢´«ÊäÄ£Ê½ */
+#define	DMAC_CFG_SRC_1_BURST       				(0x00)	//(0x00<<7)
+#define	DMAC_CFG_SRC_4_BURST		    		(0x01)	//(0x01<<7)
+
+/* DMA Ô´¶Ë µØÖ·±ä»¯Ä£Ê½ */
+#define	DMAC_CFG_SRC_ADDR_TYPE_LINEAR_MODE		(0x00)	//(0x00<<5)
+#define	DMAC_CFG_SRC_ADDR_TYPE_IO_MODE 			(0x01)	//(0x01<<5)
+#define	DMAC_CFG_SRC_ADDR_TYPE_HPAGE_MODE 		(0x02)	//(0x02<<5)
+#define	DMAC_CFG_SRC_ADDR_TYPE_VPAGE_MODE 		(0x03)	//(0x03<<5)
+
+
+/* DMA ´«ÊäÄ¿µÄ¶Ë ÅäÖÃ */
+/* DMA ´«ÊäÄ¿µÄ¶Ë NÐÍDMA Ä¿µÄÑ¡Ôñ */
+#define	DMAC_CFG_DEST_TYPE_IR					(0x00)	//(0x00<<16)
+#define	DMAC_CFG_DEST_TYPE_SPDIF		    	(0x01)	//(0x01<<16)
+#define	DMAC_CFG_DEST_TYPE_IIS			    	(0x02)	//(0x02<<16)
+#define	DMAC_CFG_DEST_TYPE_AC97			    	(0x03)	//(0x03<<16)
+#define	DMAC_CFG_DEST_TYPE_SPI0				    (0x04)	//(0x04<<16)
+#define	DMAC_CFG_DEST_TYPE_SPI1				    (0x05)	//(0x05<<16)
+#define	DMAC_CFG_DEST_TYPE_SPI2				    (0x06)	//(0x06<<16)
+#define	DMAC_CFG_DEST_TYPE_UART0				(0x08)	//(0x08<<16)
+#define	DMAC_CFG_DEST_TYPE_UART1				(0x09)	//(0x09<<16)
+#define	DMAC_CFG_DEST_TYPE_UART2				(0x0a)	//(0x0a<<16)
+#define	DMAC_CFG_DEST_TYPE_UART3				(0x0b)	//(0x0b<<16)
+#define	DMAC_CFG_DEST_TYPE_AUDIO_DA				(0x0c)	//(0x0c<<16)
+
+#define	DMAC_CFG_DEST_TYPE_NFC_DEBUG			(0x0f)	//(0x0f<<16)
+#define	DMAC_CFG_DEST_TYPE_N_SRAM 				(0x10)	//(0x10<<16)
+#define	DMAC_CFG_DEST_TYPE_N_SDRAM				(0x11)	//(0x11<<16)
+#define	DMAC_CFG_DEST_TYPE_UART4				(0x12)	//(0x12<<16)
+#define	DMAC_CFG_DEST_TYPE_UART5				(0x13)	//(0x13<<16)
+#define	DMAC_CFG_DEST_TYPE_UART6				(0x14)	//(0x14<<16)
+#define	DMAC_CFG_DEST_TYPE_UART7				(0x15)	//(0x15<<16)
+
+/* DMA ´«ÊäÄ¿µÄ¶Ë DÐÍDMA Ä¿µÄÑ¡Ôñ */
+#define	DMAC_CFG_DEST_TYPE_D_SRAM 				(0x00)	//(0x00<<16)
+#define	DMAC_CFG_DEST_TYPE_D_SDRAM				(0x01)	//(0x01<<16)
+#define	DMAC_CFG_DEST_TYPE_TCON0				(0x02)	//(0x02<<16)
+#define	DMAC_CFG_DEST_TYPE_NFC  		    	(0x03)	//(0x03<<16)
+#define	DMAC_CFG_DEST_TYPE_USB0			    	(0x04)	//(0x04<<16)
+#define	DMAC_CFG_DEST_TYPE_USB1			    	(0x05)	//(0x05<<16)
+#define	DMAC_CFG_DEST_TYPE_SDC1			    	(0x07)	//(0x07<<16)
+#define	DMAC_CFG_DEST_TYPE_SDC2 				(0x08)	//(0x08<<16)
+#define	DMAC_CFG_DEST_TYPE_SDC3 				(0x09)	//(0x09<<16)
+#define	DMAC_CFG_DEST_TYPE_MSC  				(0x0a)	//(0x0a<<16)
+#define	DMAC_CFG_DEST_TYPE_EMAC 				(0x0b)	//(0x0b<<16)
+#define	DMAC_CFG_DEST_TYPE_SS   				(0x0d)	//(0x0d<<16)
+#define	DMAC_CFG_DEST_TYPE_USB2			    	(0x0f)	//(0x0f<<16)
+#define	DMAC_CFG_DEST_TYPE_ATA			    	(0x10)	//(0x10<<16)
+
+/* DMA ´«ÊäÔ´¶Ë ÅäÖÃ */
+/* DMA ´«ÊäÔ´¶Ë NÐÍDMA Ä¿µÄÑ¡Ôñ */
+#define	DMAC_CFG_SRC_TYPE_IR					(0x00)	//(0x00<<0)
+#define	DMAC_CFG_SRC_TYPE_SPDIF		    	   	(0x01)	//(0x01<<0)
+#define	DMAC_CFG_SRC_TYPE_IIS			    	(0x02)	//(0x02<<0)
+#define	DMAC_CFG_SRC_TYPE_AC97			    	(0x03)	//(0x03<<0)
+#define	DMAC_CFG_SRC_TYPE_SPI0				    (0x04)	//(0x04<<0)
+#define	DMAC_CFG_SRC_TYPE_SPI1				    (0x05)	//(0x05<<0)
+#define	DMAC_CFG_SRC_TYPE_SPI2				    (0x06)	//(0x06<<0)
+#define	DMAC_CFG_SRC_TYPE_UART0				    (0x08)	//(0x08<<0)
+#define	DMAC_CFG_SRC_TYPE_UART1				    (0x09)	//(0x09<<0)
+#define	DMAC_CFG_SRC_TYPE_UART2				    (0x0a)	//(0x0a<<0)
+#define	DMAC_CFG_SRC_TYPE_UART3				    (0x0b)	//(0x0b<<0)
+#define	DMAC_CFG_SRC_TYPE_AUDIO 				(0x0c)	//(0x0c<<0)
+#define	DMAC_CFG_SRC_TYPE_TP     				(0x0d)	//(0x0d<<0)
+
+#define	DMAC_CFG_SRC_TYPE_NFC_DEBUG			    (0x0f)	//(0x0f<<0)
+#define	DMAC_CFG_SRC_TYPE_N_SRAM 				(0x10)	//(0x10<<0)
+#define	DMAC_CFG_SRC_TYPE_N_SDRAM				(0x11)	//(0x11<<0)
+#define	DMAC_CFG_SRC_TYPE_UART4				    (0x12)	//(0x12<<0)
+#define	DMAC_CFG_SRC_TYPE_UART5				    (0x13)	//(0x13<<0)
+#define	DMAC_CFG_SRC_TYPE_UART6				    (0x14)	//(0x14<<0)
+#define	DMAC_CFG_SRC_TYPE_UART7				    (0x15)	//(0x15<<0)
+
+/* DMA ´«ÊäÔ´¶Ë DÐÍDMA Ä¿µÄÑ¡Ôñ */
+#define	DMAC_CFG_SRC_TYPE_D_SRAM 				(0x00)	//(0x00<<0)
+#define	DMAC_CFG_SRC_TYPE_D_SDRAM				(0x01)	//(0x01<<0)
+#define	DMAC_CFG_SRC_TYPE_TCON0				    (0x02)	//(0x02<<0)
+#define	DMAC_CFG_SRC_TYPE_NFC  		    	   	(0x03)	//(0x03<<0)
+#define	DMAC_CFG_SRC_TYPE_USB0			    	(0x04)	//(0x04<<0)
+#define	DMAC_CFG_SRC_TYPE_USB1			    	(0x05)	//(0x05<<0)
+#define	DMAC_CFG_SRC_TYPE_SDC1			    	(0x07)	//(0x07<<0)
+#define	DMAC_CFG_SRC_TYPE_SDC2 				    (0x08)	//(0x08<<0)
+#define	DMAC_CFG_SRC_TYPE_SDC3 				    (0x09)	//(0x09<<0)
+#define	DMAC_CFG_SRC_TYPE_MSC  				    (0x0a)	//(0x0a<<0)
+#define	DMAC_CFG_SRC_TYPE_EMAC 				    (0x0c)	//(0x0c<<0)
+#define	DMAC_CFG_SRC_TYPE_SS   				    (0x0e)	//(0x0e<<0)
+#define	DMAC_CFG_SRC_TYPE_USB2			    	(0x0f)	//(0x0f<<0)
+#define	DMAC_CFG_SRC_TYPE_ATA			    	(0x10)	//(0x10<<0)
+
+
+typedef enum
+{
+    NDMA_IR                      = 0,
+    NDMA_SPDIF                      ,
+    NDMA_IIS                        ,
+    NDMA_AC97                       ,
+    NDMA_SPI0                       ,
+    NDMA_SPI1                       ,
+    NDMA_UART0                   = 8,
+    NDMA_UART1                      ,
+    NDMA_UART2                      ,
+    NDMA_UART3                      ,
+    NDMA_AUDIO                      ,
+    NDMA_TP                         ,
+    NDMA_SRAM                   = 16,
+    NDMA_SDRAM                      ,
+    NDMA_
+}
+__ndma_drq_type_t;
+
+typedef enum
+{
+    DDMA_SRC_SRAM                   = 0,
+    DDMA_SRC_SDRAM                     ,
+    DDMA_SRC_LCD                       ,
+    DDMA_SRC_NAND                      ,
+    DDMA_SRC_USB0                      ,
+    DDMA_SRC_USB1                      ,
+    DDMA_SRC_SD0                       ,
+    DDMA_SRC_SD1                       ,
+    DDMA_SRC_SD2                       ,
+    DDMA_SRC_SD3                       ,
+    DDMA_SRC_MS                        ,
+    DDMA_SRC_EMAC                   = 0xc,
+    DDMA_SRC_SS                     = 0xe,
+    DDMA_SRC_
+}
+__ddma_src_type_t;
+
+typedef enum
+{
+    DDMA_DST_SRAM                   = 0,
+    DDMA_DST_SDRAM                     ,
+    DDMA_DST_LCD                       ,
+    DDMA_DST_NAND                      ,
+    DDMA_DST_USB0                      ,
+    DDMA_DST_USB1                      ,
+    DDMA_DST_SD0                       ,
+    DDMA_DST_SD1                       ,
+    DDMA_DST_SD2                       ,
+    DDMA_DST_SD3                       ,
+    DDMA_DST_MS                        ,
+    DDMA_DST_EMAC                   = 0xb,
+    DDMA_DST_SS                     = 0xd,
+    DDMA_DST_
+}
+__ddma_dst_type_t;
+
+typedef struct  __dma_config_set
+{
+    unsigned int      src_drq_type     ; //Ô´µØÖ·´æ´¢ÀàÐÍ£¬ÈçDRAM, SPI,NANDµÈ£¬¸ù¾ÝÑ¡ÔñNDMA»òÕßDDMA, Ñ¡Ôñ __ndma_drq_type_t»òÕß __ddma_src_type_t
+    unsigned int      src_addr_type    ; //Ô­µØÖ·ÀàÐÍ NDMAÏÂ 0:µÝÔöÄ£Ê½  1:±£³Ö²»±ä  DDMAÏÂ 0:µÝÔöÄ£Ê½  1:±£³Ö²»±ä  2:HÄ£Ê½  3:VÄ£Ê½
+    unsigned int      src_burst_length ; //·¢ÆðÒ»´Îburst¿í¶È Ìî0¶ÔÓ¦ÓÚ1£¬Ìî1¶ÔÓ¦ÓÚ4,
+    unsigned int      src_data_width   ; //Êý¾Ý´«Êä¿í¶È£¬0:Ò»´Î´«Êä8bit£¬1:Ò»´Î´«Êä16bit£¬2:Ò»´Î´«Êä32bit£¬3:±£Áô
+    unsigned int      dst_drq_type     ; //Ô´µØÖ·´æ´¢ÀàÐÍ£¬ÈçDRAM, SPI,NANDµÈ£¬¸ù¾ÝÑ¡ÔñNDMA»òÕßDDMA, Ñ¡Ôñ __ndma_drq_type_t»òÕß __ddma_dst_type_t
+    unsigned int      dst_addr_type    ; //Ô­µØÖ·ÀàÐÍ NDMAÏÂ 0:µÝÔöÄ£Ê½  1:±£³Ö²»±ä  DDMAÏÂ 0:µÝÔöÄ£Ê½  1:±£³Ö²»±ä  2:HÄ£Ê½  3:VÄ£Ê½
+    unsigned int      dst_burst_length ; //·¢ÆðÒ»´Îburst¿í¶È Ìî0¶ÔÓ¦ÓÚ1£¬Ìî1¶ÔÓ¦ÓÚ4,
+    unsigned int      dst_data_width   ; //Êý¾Ý´«Êä¿í¶È£¬0:Ò»´Î´«Êä8bit£¬1:Ò»´Î´«Êä16bit£¬2:Ò»´Î´«Êä32bit£¬3:±£Áô
+    unsigned int      wait_state       ; //µÈ´ýÊ±ÖÓ¸öÊý Ñ¡Ôñ·¶Î§´Ó0-7£¬Ö»¶ÔNDMAÓÐÐ§
+    unsigned int      continuous_mode  ; //Ñ¡ÔñÁ¬Ðø¹¤×÷Ä£Ê½ 0:´«ÊäÒ»´Î¼´½áÊø 1:·´¸´´«Êä£¬µ±Ò»´ÎDMA´«Êä½áÊøºó£¬ÖØÐÂ¿ªÊ¼´«Êä
+}
+__dma_config_t;
+
+typedef struct 	__dma_setting_set
+{
+    __dma_config_t         cfg;	    	    //DMAÅäÖÃ²ÎÊý
+    unsigned int           pgsz;            //DEÊ¹ÓÃ²ÎÊý£¬¿é¿½±´Ê¹ÓÃ
+    unsigned int           pgstp;           //DEÊ¹ÓÃ²ÎÊý£¬¿é¿½±´Ê¹ÓÃ
+    unsigned int           cmt_blk_cnt;     //DEÊ¹ÓÃ²ÎÊý£¬¿é¿½±´Ê¹ÓÃ
+}__dma_setting_t;
+
+
+extern    unsigned int 	DMA_Request			(unsigned int dmatype);
+extern    int 			DMA_Release			(unsigned int hDma);
+extern    int 			DMA_Setting			(unsigned int hDMA, void *cfg);
+extern    int 			DMA_Start			(unsigned int hDMA, unsigned int saddr, unsigned int daddr, unsigned int bytes);
+extern    int 			DMA_Stop			(unsigned int hDma);
+extern    int 			DMA_Restart			(unsigned int hDma);
+extern    int 			DMA_QueryStatus		(unsigned int hDma);
+extern    int 			DMA_QueryChannalNo	(unsigned int hDma);
+
+void print_nand_dma(unsigned int hDma);
+
+#endif	//_DMA_H_
+
+/* end of _DMA_H_ */
+
+
diff --git a/arch/arm/include/asm/arch-sunxi/dma_i.h b/arch/arm/include/asm/arch-sunxi/dma_i.h
new file mode 100644
index 0000000..fb027cf
--- /dev/null
+++ b/arch/arm/include/asm/arch-sunxi/dma_i.h
@@ -0,0 +1,127 @@
+/*
+**********************************************************************************************************************
+*											        eGon
+*						           the Embedded GO-ON Bootloader System
+*									       eGON driver sub-system
+*
+*						  Copyright(C), 2006-2010, SoftWinners Microelectronic Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    : dmac_i.h
+*
+* By      : Jerry
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#ifndef	_DMAC_I_H_
+#define	_DMAC_I_H_
+
+#define CFG_SW_DMA_NORMAL_MAX       8
+#define CFG_SW_DMA_DEDICATE_MAX     8
+
+#define DMAC_REGS_BASE				0x01c02000
+
+
+#define CFG_SW_DMA_NORMAL_BASE              (DMAC_REGS_BASE + 0x100              )
+#define CFS_SW_DMA_NORMAL0                  (CFG_SW_DMA_NORMAL_BASE + 0x20 * 0   )
+#define CFS_SW_DMA_NORMAL1                  (CFG_SW_DMA_NORMAL_BASE + 0x20 * 1   )
+#define CFS_SW_DMA_NORMAL2                  (CFG_SW_DMA_NORMAL_BASE + 0x20 * 2   )
+#define CFS_SW_DMA_NORMAL3                  (CFG_SW_DMA_NORMAL_BASE + 0x20 * 3   )
+#define CFS_SW_DMA_NORMAL4                  (CFG_SW_DMA_NORMAL_BASE + 0x20 * 4   )
+#define CFS_SW_DMA_NORMAL5                  (CFG_SW_DMA_NORMAL_BASE + 0x20 * 5   )
+#define CFS_SW_DMA_NORMAL6                  (CFG_SW_DMA_NORMAL_BASE + 0x20 * 6   )
+#define CFS_SW_DMA_NORMAL7                  (CFG_SW_DMA_NORMAL_BASE + 0x20 * 7   )
+
+#define CFG_SW_DMA_DEDICATE_BASE            (DMAC_REGS_BASE + 0x300               )
+#define CFG_SW_DMA_DEDICATE0                (CFG_SW_DMA_DEDICATE_BASE + 0x20 * 0 )
+#define CFG_SW_DMA_DEDICATE1                (CFG_SW_DMA_DEDICATE_BASE + 0x20 * 1 )
+#define CFG_SW_DMA_DEDICATE2                (CFG_SW_DMA_DEDICATE_BASE + 0x20 * 2 )
+#define CFG_SW_DMA_DEDICATE3                (CFG_SW_DMA_DEDICATE_BASE + 0x20 * 3 )
+#define CFG_SW_DMA_DEDICATE4                (CFG_SW_DMA_DEDICATE_BASE + 0x20 * 4 )
+#define CFG_SW_DMA_DEDICATE5                (CFG_SW_DMA_DEDICATE_BASE + 0x20 * 5 )
+#define CFG_SW_DMA_DEDICATE6                (CFG_SW_DMA_DEDICATE_BASE + 0x20 * 6 )
+#define CFG_SW_DMA_DEDICATE7                (CFG_SW_DMA_DEDICATE_BASE + 0x20 * 7 )
+
+#define CFG_SW_DMA_OTHER_BASE               (DMAC_REGS_BASE + 0x300 + 0x10       )
+#define CFG_SW_DMA_DEDICATE0_OTHER          (CFG_SW_DMA_OTHER_BASE + 0x20 * 0    )
+#define CFG_SW_DMA_DEDICATE1_OTHER          (CFG_SW_DMA_OTHER_BASE + 0x20 * 1    )
+#define CFG_SW_DMA_DEDICATE2_OTHER          (CFG_SW_DMA_OTHER_BASE + 0x20 * 2    )
+#define CFG_SW_DMA_DEDICATE3_OTHER          (CFG_SW_DMA_OTHER_BASE + 0x20 * 3    )
+#define CFG_SW_DMA_DEDICATE4_OTHER          (CFG_SW_DMA_OTHER_BASE + 0x20 * 4    )
+#define CFG_SW_DMA_DEDICATE5_OTHER          (CFG_SW_DMA_OTHER_BASE + 0x20 * 5    )
+#define CFG_SW_DMA_DEDICATE6_OTHER          (CFG_SW_DMA_OTHER_BASE + 0x20 * 6    )
+#define CFG_SW_DMA_DEDICATE7_OTHER          (CFG_SW_DMA_OTHER_BASE + 0x20 * 7    )
+
+struct sw_dma
+{
+    volatile unsigned int config;           /* DMAÅäÖÃ²ÎÊý              */
+    volatile unsigned int src_addr;         /* DMA´«ÊäÔ´µØÖ·            */
+    volatile unsigned int dst_addr;         /* DMA´«ÊäÄ¿µÄµØÖ·          */
+    volatile unsigned int bytes;            /* DMA´«Êä×Ö½ÚÊý            */
+};
+
+typedef volatile struct sw_dma *sw_dma_t;
+
+struct sw_dma_other
+{
+    volatile unsigned int page_size;        /* DMA´«ÊäPAGE SIZE         */
+    volatile unsigned int page_step;        /* DMA´«ÊäPAGE STEP         */
+    volatile unsigned int comity_counter;   /* DMA´«Êäcomity counter    */
+};
+
+typedef volatile struct sw_dma_other *sw_dma_other_t;
+
+typedef struct sw_dma_channal_set
+{
+    unsigned int            used;           /* DMAÊÇ·ñ±»Ê¹ÓÃ            */
+      signed int            channalNo;      /* DMAÍ¨µÀ±àºÅ              */
+    sw_dma_t                channal;        /* DMAÍ¨µÀ                  */
+    sw_dma_other_t          other;          /* DMAÆäËüÉèÖÃ              */
+}
+sw_dma_channal_set_t;
+
+
+typedef struct __ndma_config_set
+{
+    unsigned int      src_drq_type     : 5;            //Ô´µØÖ·´æ´¢ÀàÐÍ£¬ÈçDRAM, SPI,NANDµÈ£¬²Î¼û  __ndma_drq_type_t
+    unsigned int      src_addr_type    : 1;            //Ô­µØÖ·ÀàÐÍ£¬ÈçµÝÔö£¬»òÕß²»±ä  0:µÝÔöÄ£Ê½  1:±£³Ö²»±ä
+    unsigned int      src_secure       : 1;            //source secure  0:secure  1:not secure
+    unsigned int      src_burst_length : 2;            //·¢ÆðÒ»´Îburst¿í¶È 0:1   1:4   2:8
+    unsigned int      src_data_width   : 2;            //Êý¾Ý´«Êä¿í¶È£¬0:Ò»´Î´«Êä8bit£¬1:Ò»´Î´«Êä16bit£¬2:Ò»´Î´«Êä32bit£¬3:±£Áô
+    unsigned int      reserved0        : 5;
+    unsigned int      dst_drq_type     : 5;            //Ä¿µÄµØÖ·´æ´¢ÀàÐÍ£¬ÈçDRAM, SPI,NANDµÈ
+    unsigned int      dst_addr_type    : 1;            //Ä¿µÄµØÖ·ÀàÐÍ£¬ÈçµÝÔö£¬»òÕß²»±ä  0:µÝÔöÄ£Ê½  1:±£³Ö²»±ä
+    unsigned int      dst_secure       : 1;            //dest secure  0:secure  1:not secure
+    unsigned int      dst_burst_length : 2;            //·¢ÆðÒ»´Îburst¿í¶È Ìî0¶ÔÓ¦ÓÚ1£¬Ìî1¶ÔÓ¦ÓÚ4,
+    unsigned int      dst_data_width   : 2;            //Êý¾Ý´«Êä¿í¶È£¬0:Ò»´Î´«Êä8bit£¬1:Ò»´Î´«Êä16bit£¬2:Ò»´Î´«Êä32bit£¬3:±£Áô
+    unsigned int      wait_state       : 3;            //µÈ´ýÊ±ÖÓ¸öÊý Ñ¡Ôñ·¶Î§´Ó0-7
+    unsigned int      continuous_mode  : 1;            //Ñ¡ÔñÁ¬Ðø¹¤×÷Ä£Ê½ 0:´«ÊäÒ»´Î¼´½áÊø 1:·´¸´´«Êä£¬µ±Ò»´ÎDMA´«Êä½áÊøºó£¬ÖØÐÂ¿ªÊ¼´«Êä
+    unsigned int      reserved1        : 1;
+}
+__ndma_config_t;
+
+typedef struct __ddma_config_set
+{
+    unsigned int      src_drq_type     : 5;            //Ô´µØÖ·´æ´¢ÀàÐÍ£¬ÈçDRAM, SPI,NANDµÈ£¬²Î¼û  __ddma_src_type_t
+    unsigned int      src_addr_type    : 2;            //Ô­µØÖ·ÀàÐÍ£¬ÈçµÝÔö£¬»òÕß²»±ä  0:µÝÔöÄ£Ê½  1:±£³Ö²»±ä  2:HÄ£Ê½  3:VÄ£Ê½
+    unsigned int      src_burst_length : 2;            //·¢ÆðÒ»´Îburst¿í¶È Ìî0¶ÔÓ¦ÓÚ1£¬Ìî1¶ÔÓ¦ÓÚ4,
+    unsigned int      src_data_width   : 2;            //Êý¾Ý´«Êä¿í¶È£¬0:Ò»´Î´«Êä8bit£¬1:Ò»´Î´«Êä16bit£¬2:Ò»´Î´«Êä32bit£¬3:±£Áô
+    unsigned int      reserved0        : 5;
+    unsigned int      dst_drq_type     : 5;            //Ä¿µÄµØÖ·´æ´¢ÀàÐÍ£¬ÈçDRAM, SPI,NANDµÈ, ²Î¼û  __ddma_dst_type_t
+    unsigned int      dst_addr_type    : 2;            //Ä¿µÄµØÖ·ÀàÐÍ£¬ÈçµÝÔö£¬»òÕß²»±ä 0:µÝÔöÄ£Ê½  1:±£³Ö²»±ä  2:HÄ£Ê½  3:VÄ£Ê½
+    unsigned int      dst_burst_length : 2;            //·¢ÆðÒ»´Îburst¿í¶È Ìî0¶ÔÓ¦ÓÚ1£¬Ìî1¶ÔÓ¦ÓÚ4,
+    unsigned int      dst_data_width   : 2;            //Êý¾Ý´«Êä¿í¶È£¬0:Ò»´Î´«Êä8bit£¬1:Ò»´Î´«Êä16bit£¬2:Ò»´Î´«Êä32bit£¬3:±£Áô
+    unsigned int      reserved1        : 3;
+    unsigned int      continuous_mode  : 1;            //Ñ¡ÔñÁ¬Ðø¹¤×÷Ä£Ê½ 0:´«ÊäÒ»´Î¼´½áÊø 1:·´¸´´«Êä£¬µ±Ò»´ÎDMA´«Êä½áÊøºó£¬ÖØÐÂ¿ªÊ¼´«Êä
+    unsigned int      reserved2        : 1;
+}
+__ddma_config_t;
+
+#endif	/* _EGON2_DMAC_I_H_ */
+
+
diff --git a/common/cmd_nand.c b/common/cmd_nand.c
index f9ced9d..702701a 100644
--- a/common/cmd_nand.c
+++ b/common/cmd_nand.c
@@ -24,9 +24,11 @@
 #include <command.h>
 #include <watchdog.h>
 #include <malloc.h>
+#include <errno.h>
 #include <asm/byteorder.h>
 #include <jffs2/jffs2.h>
 #include <nand.h>
+#include <packimg.h>
 
 #if defined(CONFIG_CMD_MTDPARTS)
 
@@ -462,6 +464,66 @@ static void adjust_size_for_badblocks(loff_t *size, loff_t offset, int dev)
 	}
 }
 
+static int erase_and_write_block(nand_info_t *nand, loff_t off, char *wbuff, char *rbuff, int option)
+{
+	int i, err;
+	size_t retlen = 0;
+	struct erase_info erase;
+
+	// erase block
+	memset(&erase, 0, sizeof(erase));
+	erase.mtd = nand;
+	erase.addr = off;
+	erase.len = nand->erasesize;
+	if (nand->_erase(nand, &erase))
+		goto bad_out;
+
+	// skip write test
+	if (option == 1)
+		return 0;
+
+	// write test
+	if (option == 0)
+		for (i = 0; i < nand->erasesize / sizeof(unsigned int); i++)
+			((unsigned int *)wbuff)[i] = rand();
+
+	// write block
+	err = nand->_write(nand, off, nand->erasesize, &retlen, (void *)wbuff);
+	if (err || retlen != nand->erasesize) {
+		printf("write block %010llx fail %d\n", off, err);
+		goto bad_out;
+	}
+
+	// restore data
+	if (option == 2)
+		return 0;
+
+	// read block
+	err = nand->_read(nand, off, nand->erasesize, &retlen, (void *)rbuff);
+	if ((err && err != -EUCLEAN) || retlen != nand->erasesize) {
+		printf("read block %010llx fail %d\n", off, err);
+		goto bad_out;
+	}
+
+/*
+	if (err == -EUCLEAN)
+		printf("ECC corrected at block %010llx\n", off);
+*/
+
+	// compare data
+	if (memcmp(rbuff, wbuff, nand->erasesize)) {
+		printf("memcmp block %010llx fail\n", off);
+		goto bad_out;
+	}
+
+	return 0;
+
+bad_out:
+	printf("bad block at %010llx\n", off);
+	nand->_block_markbad(nand, off);
+	return -1;
+}
+
 static int do_nand(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	int i, ret = 0;
@@ -721,6 +783,16 @@ static int do_nand(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 				ret = mtd_read_oob(nand, off, &ops);
 			else
 				ret = mtd_write_oob(nand, off, &ops);
+#ifdef CONFIG_CMD_NAND_1K
+		} else if (!strcmp(s, ".1k")) {
+			int nand1k_read(char *buff, loff_t offs, size_t count);
+			int nand1k_write(const char *buff, loff_t offs, size_t count);
+			
+			if (read)
+				nand1k_read((char *)addr, off, size);
+			else
+				nand1k_write((char *)addr, off, size);
+#endif
 		} else if (raw) {
 			ret = raw_access(nand, addr, off, pagecount, read);
 		} else {
@@ -779,6 +851,99 @@ static int do_nand(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		return ret;
 	}
 
+	// nand test [-k] [-s] [off] [size]
+	if (strcmp(cmd, "test") == 0) {
+		loff_t block_start, block_end, block_size;
+		int keep_data = 0, skip_write = 0;
+		char *save_buffer, *write_buffer, *read_buffer;
+		int pos = 2;
+		int index = 0;
+
+		if (argc >= 3) {
+			if (!strcmp("-k", argv[2]))
+				keep_data = 1;
+			else if (!strcmp("-s", argv[2]))
+				skip_write = 1;
+
+			if (argc > 3) {
+				if (!strcmp("-k", argv[3]))
+					keep_data = 1;
+				else if (!strcmp("-s", argv[3]))
+					skip_write = 1;
+			}
+		}
+
+		if (keep_data)
+			pos++;
+		if (skip_write)
+			pos++;
+
+		if (arg_off_size(argc - pos, argv + pos, &index, &block_start, &block_size, &maxsize)) {
+			printf("invalid arguments\n");
+			return -EINVAL;
+		}
+
+		write_buffer = malloc(nand->erasesize);
+		if (write_buffer == NULL) {
+			printf("alloc write buffer fail\n");
+			return -ENOMEM;
+		}
+
+		read_buffer = malloc(nand->erasesize);
+		if (read_buffer == NULL) {
+			printf("alloc read buffer fail\n");
+			free(write_buffer);
+			return -ENOMEM;
+		}
+
+		if (keep_data) {
+			save_buffer = malloc(nand->erasesize);
+			if (save_buffer == NULL) {
+				printf("alloc save buffer fail\n");
+				free(read_buffer);
+				free(write_buffer);
+				return -ENOMEM;
+			}
+		}
+
+		block_end = block_start + block_size;
+		block_start &= ~(typeof(block_start))(nand->erasesize - 1);
+		for ( ; block_start < block_end; block_start += nand->erasesize) {
+			int err, data_saved = 0;
+			size_t retlen = 0;
+
+			/*if (!(block_start % (nand->erasesize * 128))) //it causes float problem...WTF!
+				printf("check block at %010llx\n", block_start);*/
+			printf("check block at %010llx\n", block_start);
+
+			// check bad block
+			if (nand->_block_isbad(nand, block_start)) {
+				printf("bad block at %010llx\n", block_start);
+				continue;
+			}
+
+			// save origin data
+			if (keep_data) {
+				err = nand->_read(nand, block_start, nand->erasesize, &retlen, (void *)save_buffer);
+				if ((err == 0 || err == -EUCLEAN) && (retlen == nand->erasesize))
+					data_saved = 1;
+			}
+
+			// erase and write test
+			if (erase_and_write_block(nand, block_start, write_buffer, read_buffer, skip_write))
+				continue;
+
+			// restore data
+			if (data_saved)
+				erase_and_write_block(nand, block_start, save_buffer, read_buffer, 2);
+		}
+
+		free(save_buffer);
+		free(read_buffer);
+		free(write_buffer);
+		return 0;
+	}
+
 	if (strcmp(cmd, "biterr") == 0) {
 		/* todo */
 		return 1;
@@ -870,6 +1035,7 @@ static char nand_help_text[] =
 	"nand scrub [-y] off size | scrub.part partition | scrub.chip\n"
 	"    really clean NAND erasing bad blocks (UNSAFE)\n"
 	"nand markbad off [...] - mark bad block(s) at offset (UNSAFE)\n"
+	"nand test [-k] [-s] [off] [size] - test the whole flash chip for bad blocks\n"
 	"nand biterr off - make a bit error at offset (UNSAFE)"
 #ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
 	"\n"
@@ -884,6 +1050,11 @@ static char nand_help_text[] =
 	"nand env.oob set off|partition - set enviromnent offset\n"
 	"nand env.oob get - get environment offset"
 #endif
+#ifdef CONFIG_CMD_NAND_1K
+	"\n"
+	"nand read.1k - addr off|partition size\n"
+	"    write.1k - addr off|partition size\n"
+#endif
 	"";
 #endif
 
diff --git a/common/spl/spl_nand.c b/common/spl/spl_nand.c
index 9b200bc..eecfcb6 100644
--- a/common/spl/spl_nand.c
+++ b/common/spl/spl_nand.c
@@ -2,13 +2,111 @@
  * Copyright (C) 2011
  * Corscience GmbH & Co. KG - Simon Schwarz <schwarz@corscience.de>
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 #include <common.h>
 #include <config.h>
 #include <spl.h>
 #include <asm/io.h>
 #include <nand.h>
+#include <image.h>
+
+#ifdef CONFIG_SUNXI
+
+extern int sunxi_nand_spl_page_size;
+extern int sunxi_nand_spl_block_size;
+
+int nand_spl_isbad(uint32_t offs);
+void nand_spl_read(uint32_t offs, int size, void *dst);
+/*
+static void load_uimage(struct image_header *header, uint32_t offs)
+{
+	char *name;
+	uint32_t load_addr, size;
+
+	nand_spl_load_image(offs, CONFIG_SYS_NAND_PAGE_SIZE, (void *)header);
+	if (image_get_magic(header) != IH_MAGIC) {
+		error("image at flash offset %x has no signature\n", offs);
+		return;
+	}
+
+	load_addr = image_get_load(header);
+	size = image_get_data_size(header);
+	name = image_get_name(header);
+	debug("load image %s from flash offset %x to memory %x size %x\n",
+		  name, offs, load_addr, size);
+
+	nand_spl_load_image(offs, size + sizeof(struct image_header), 
+						load_addr - sizeof(struct image_header));
+}
+*/
+
+static uint32_t calc_crc(void *buff, int size)
+{
+	int i;
+	uint32_t ret = 0;
+	for (i = 0; i < size; i += 4)
+		ret += *(uint32_t *)(buff + i);
+	return ret;
+}
+
+static int block_isbad(char *record, uint32_t start, uint32_t offs)
+{
+	int ret;
+	int i = (offs - start) / CONFIG_SYS_NAND_BLOCK_SIZE;
+	if (record[i] == 0) {
+		ret = nand_spl_isbad(offs);
+		if (ret)
+			record[i] = 1;
+		else
+			record[i] = 2;
+	}
+	else {
+		ret = record[i] == 1 ? 1 : 0;
+	}
+	return ret;
+}
+
+static void read_skip_bad(char *record, uint32_t start, 
+						  uint32_t offs, uint32_t image_size, void *dst)
+{
+	int size = image_size;
+	uint32_t to, len, bound;
+
+	while (size > 0) {
+		if (block_isbad(record, start, offs)) {
+			offs += CONFIG_SYS_NAND_BLOCK_SIZE;
+			continue;
+		}
+			
+		to = roundup(offs, CONFIG_SYS_NAND_BLOCK_SIZE);
+		bound = (to == offs) ? CONFIG_SYS_NAND_BLOCK_SIZE : (to - offs);
+		len = bound > size ? size : bound;
+		nand_spl_read(offs, len, dst);
+		offs += len;
+		dst += len;
+		size -= len;
+	}
+}
+
+
+#endif
 
 void spl_nand_load_image(void)
 {
@@ -23,6 +121,11 @@ void spl_nand_load_image(void)
 	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE);
 #ifdef CONFIG_SPL_OS_BOOT
 	if (!spl_start_uboot()) {
+
+#ifdef CONFIG_SUNXI
+		if (load_packimg(CONFIG_SUNXI_PACKIMG_START, CONFIG_SUNXI_PACKIMG_END, (void *)CONFIG_SYS_TEXT_BASE))
+			goto uboot;
+#else
 		/*
 		 * load parameter image
 		 * load to temp position since nand_spl_load_image reads
@@ -41,6 +144,7 @@ void spl_nand_load_image(void)
 				src++, dst++) {
 			writel(readl(src), dst);
 		}
+#endif
 
 		/* load linux */
 		nand_spl_load_image(CONFIG_SYS_NAND_SPL_KERNEL_OFFS,
@@ -60,6 +164,9 @@ void spl_nand_load_image(void)
 		}
 	}
 #endif
+#ifdef CONFIG_SUNXI
+uboot:
+#endif
 #ifdef CONFIG_NAND_ENV_DST
 	nand_spl_load_image(CONFIG_ENV_OFFSET,
 		sizeof(*header), (void *)header);
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index a79c391..f8329c8 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -8,3 +8,4 @@
 obj-$(CONFIG_APBH_DMA) += apbh_dma.o
 obj-$(CONFIG_FSL_DMA) += fsl_dma.o
 obj-$(CONFIG_OMAP3_DMA) += omap3_dma.o
+obj-$(CONFIG_SUNXI_DMA) += sunxi_dma.o
diff --git a/drivers/dma/sunxi_dma.c b/drivers/dma/sunxi_dma.c
new file mode 100644
index 0000000..83bf60a
--- /dev/null
+++ b/drivers/dma/sunxi_dma.c
@@ -0,0 +1,327 @@
+/*
+**********************************************************************************************************************
+*											        eGon
+*						           the Embedded GO-ON Bootloader System
+*									       eGON driver sub-system
+*
+*						  Copyright(C), 2006-2010, SoftWinners Microelectronic Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    : dma.c
+*
+* By      : Jerry
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#include <asm/arch/dma_i.h>
+#include <asm/arch/dma.h>
+#include <common.h>
+
+sw_dma_channal_set_t  dma_channal[CFG_SW_DMA_NORMAL_MAX + CFG_SW_DMA_DEDICATE_MAX] =
+{
+    {0, -1, (sw_dma_t)CFS_SW_DMA_NORMAL0  , 0                                           },
+    {0, -1, (sw_dma_t)CFS_SW_DMA_NORMAL1  , 0                                           },
+    {0, -1, (sw_dma_t)CFS_SW_DMA_NORMAL2  , 0                                           },
+    {0, -1, (sw_dma_t)CFS_SW_DMA_NORMAL3  , 0                                           },
+    {0, -1, (sw_dma_t)CFS_SW_DMA_NORMAL4  , 0                                           },
+    {0, -1, (sw_dma_t)CFS_SW_DMA_NORMAL5  , 0                                           },
+    {0, -1, (sw_dma_t)CFS_SW_DMA_NORMAL6  , 0                                           },
+    {0, -1, (sw_dma_t)CFS_SW_DMA_NORMAL7  , 0                                           },
+    {0, -1, (sw_dma_t)CFG_SW_DMA_DEDICATE0, (sw_dma_other_t)CFG_SW_DMA_DEDICATE0_OTHER  },
+    {0, -1, (sw_dma_t)CFG_SW_DMA_DEDICATE1, (sw_dma_other_t)CFG_SW_DMA_DEDICATE1_OTHER  },
+    {0, -1, (sw_dma_t)CFG_SW_DMA_DEDICATE2, (sw_dma_other_t)CFG_SW_DMA_DEDICATE2_OTHER  },
+    {0, -1, (sw_dma_t)CFG_SW_DMA_DEDICATE3, (sw_dma_other_t)CFG_SW_DMA_DEDICATE3_OTHER  },
+    {0, -1, (sw_dma_t)CFG_SW_DMA_DEDICATE4, (sw_dma_other_t)CFG_SW_DMA_DEDICATE4_OTHER  },
+    {0, -1, (sw_dma_t)CFG_SW_DMA_DEDICATE5, (sw_dma_other_t)CFG_SW_DMA_DEDICATE5_OTHER  },
+    {0, -1, (sw_dma_t)CFG_SW_DMA_DEDICATE6, (sw_dma_other_t)CFG_SW_DMA_DEDICATE6_OTHER  },
+    {0, -1, (sw_dma_t)CFG_SW_DMA_DEDICATE7, (sw_dma_other_t)CFG_SW_DMA_DEDICATE7_OTHER  }
+};
+
+/*
+****************************************************************************************************
+*
+*             DMAC_RequestDma
+*
+*  Description:
+*       request dma
+*
+*  Parameters:
+*		type	0: normal timer
+*				1: special timer
+*  Return value:
+*		dma handler
+*		if 0, fail
+****************************************************************************************************
+*/
+uint DMA_Request(uint dmatype)
+{
+    uint   i;
+
+    if(dmatype == DMAC_DMATYPE_NORMAL)
+    {
+        for(i=0;i<CFG_SW_DMA_NORMAL_MAX;i++)
+        {
+            if(!dma_channal[i].used)
+            {
+                dma_channal[i].used = 1;
+                dma_channal[i].channalNo = i;
+
+                return (uint)&dma_channal[i];
+            }
+        }
+    }
+    else if(dmatype == DMAC_DMATYPE_DEDICATED)
+    {
+        for(i=CFG_SW_DMA_NORMAL_MAX;i<CFG_SW_DMA_NORMAL_MAX + CFG_SW_DMA_DEDICATE_MAX;i++)
+        {
+            if(!dma_channal[i].used)
+            {
+                dma_channal[i].used = 1;
+                dma_channal[i].channalNo = i;
+
+                return (uint)&dma_channal[i];
+            }
+        }
+    }
+
+    return 0;
+}
+/*
+****************************************************************************************************
+*
+*             DMAC_ReleaseDma
+*
+*  Description:
+*       release dma
+*
+*  Parameters:
+*       hDma	dma handler
+*
+*  Return value:
+*		EPDK_OK/FAIL
+****************************************************************************************************
+*/
+int DMA_Release(uint hDma)
+{
+    sw_dma_channal_set_t * pDma = (sw_dma_channal_set_t *)hDma;
+
+    /* stop dma                 */
+    pDma->channal->config &= 0x7fffffff; /* stop dma */
+    /* free dma handle          */
+    pDma->used = 0;
+    pDma->channalNo = -1;
+
+    return 0;
+}
+/*
+****************************************************************************************************
+*
+*             TMRC_SettingDMA
+*
+*  Description:
+*       start interrupt
+*
+*  Parameters:
+*       hTmr	timer handler
+*		pArg    *(pArg + 0)         ctrl
+*               *(pArg + 1)         page size
+*               *(pArg + 2)         page step
+*               *(pArg + 3)         comity & block count
+*
+*  Return value:
+*		EPDK_OK/FAIL
+*
+**********************************************************************************************************************
+*/
+int DMA_Setting(uint hDMA, void *cfg)
+{
+	sw_dma_channal_set_t    * pDma = (sw_dma_channal_set_t *)hDMA;
+	__dma_setting_t         * arg  = (__dma_setting_t      *)cfg;
+	uint                   value;
+
+    if(pDma->other)
+    {
+        __ddma_config_t    ddma_arg = {0};
+
+        ddma_arg.src_drq_type     = arg->cfg.src_drq_type;
+        ddma_arg.src_addr_type    = arg->cfg.src_addr_type;
+        ddma_arg.src_burst_length = arg->cfg.src_burst_length;
+        ddma_arg.src_data_width   = arg->cfg.src_data_width;
+
+        ddma_arg.dst_drq_type     = arg->cfg.dst_drq_type;
+        ddma_arg.dst_addr_type    = arg->cfg.dst_addr_type;
+        ddma_arg.dst_burst_length = arg->cfg.dst_burst_length;
+        ddma_arg.dst_data_width   = arg->cfg.dst_data_width;
+
+        ddma_arg.continuous_mode  = arg->cfg.continuous_mode;
+
+        value = *(uint *)&ddma_arg;
+        pDma->channal->config       = value & (~0x80000000);
+        pDma->other->page_size      = arg->pgsz;
+        pDma->other->page_step      = arg->pgstp;
+        pDma->other->comity_counter = arg->cmt_blk_cnt;
+    }
+    else
+    {
+        __ndma_config_t    ndma_arg = {0};
+
+        ndma_arg.src_drq_type     = arg->cfg.src_drq_type;
+        ndma_arg.src_addr_type    = arg->cfg.src_addr_type;
+        ndma_arg.src_burst_length = arg->cfg.src_burst_length;
+        ndma_arg.src_data_width   = arg->cfg.src_data_width;
+
+        ndma_arg.dst_drq_type     = arg->cfg.dst_drq_type;
+        ndma_arg.dst_addr_type    = arg->cfg.dst_addr_type;
+        ndma_arg.dst_burst_length = arg->cfg.dst_burst_length;
+        ndma_arg.dst_data_width   = arg->cfg.dst_data_width;
+
+        ndma_arg.continuous_mode  = arg->cfg.continuous_mode;
+        ndma_arg.wait_state       = arg->cfg.wait_state;
+
+        value = *(uint *)&ndma_arg;
+        pDma->channal->config       = value & (~0x80000000);
+    }
+
+    return 0;
+}
+
+/*
+**********************************************************************************************************************
+*
+*             TMRC_StartTmr
+*
+*  Description:
+*       start interrupt
+*
+*  Parameters:
+*       hTmr	timer handler
+*
+*  Return value:
+*		EPDK_OK/FAIL
+*
+****************************************************************************************************
+*/
+int DMA_Start(uint hDMA, uint saddr, uint daddr, uint bytes)
+{
+	sw_dma_channal_set_t  * pDma = (sw_dma_channal_set_t *)hDMA;
+
+    pDma->channal->src_addr  = saddr;
+    pDma->channal->dst_addr  = daddr;
+    pDma->channal->bytes     = bytes;
+    pDma->channal->config   |= 0x80000000;   /* start dma */
+
+    return 0;
+}
+/*
+**********************************************************************************************************************
+*
+*             DMAC_StopDma
+*
+*  Description:
+*       stop dma
+*
+*  Parameters:
+*       hDma	dma handler
+*
+*  Return value:
+*		EPDK_OK/FAIL
+*
+**********************************************************************************************************************
+*/
+int DMA_Stop(uint hDma)
+{
+	sw_dma_channal_set_t    * pDma = (sw_dma_channal_set_t *)hDma;
+
+    pDma->channal->config &= 0x7fffffff; /* stop dma */
+
+    return 0;
+}
+/*
+**********************************************************************************************************************
+*
+*             eGon2_RestartDMA
+*
+*  Description:
+*       restart dma
+*
+*  Parameters:
+*       hDma	dma handler
+*
+*  Return value:
+*		EPDK_OK/FAIL
+*
+**********************************************************************************************************************
+*/
+int DMA_Restart(uint hDma)
+{
+    sw_dma_channal_set_t    * pDma = (sw_dma_channal_set_t *)hDma;
+
+    pDma->channal->config |= 0x80000000;
+
+    return 0;
+}
+/*
+**********************************************************************************************************************
+*
+*             eGon2_QueryDMAStatus
+*
+*  Description:
+*
+*
+*  Parameters:
+*       hDma	dma handler
+*
+*  Return value:
+*		EPDK_OK/FAIL
+*
+**********************************************************************************************************************
+*/
+int DMA_QueryStatus(uint hDma)
+{
+    sw_dma_channal_set_t    * pDma = (sw_dma_channal_set_t *)hDma;
+
+    return (pDma->channal->config >> 31) & 0x01;
+}
+/*
+**********************************************************************************************************************
+*
+*             eGon2_QueryDMAChannalNo
+*
+*  Description:
+*
+*
+*  Parameters:
+*       hDma	dma handler
+*
+*  Return value:
+*		dma channael no.
+*
+**********************************************************************************************************************
+*/
+int DMA_QueryChannalNo(uint hDma)
+{
+    sw_dma_channal_set_t    * pDma = (sw_dma_channal_set_t *)hDma;
+
+    return pDma->channalNo;
+}
+
+void print_nand_dma(unsigned int hDma)
+{
+	sw_dma_channal_set_t    * pDma = (sw_dma_channal_set_t *)hDma;
+	debug("============= nand dma ===============\n");
+	debug("cfg=%08x page=%x step=%x count=%x\n",
+		  pDma->channal->config, pDma->other->page_size, 
+		  pDma->other->page_step, pDma->other->comity_counter);
+	debug("src=%08x dst=%08x byte=%x\n", 
+		  pDma->channal->src_addr, pDma->channal->dst_addr, pDma->channal->bytes);
+}
+
+
+
+
+
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index bf1312a..32e529b 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -62,6 +62,14 @@ obj-$(CONFIG_NAND_OMAP_GPMC) += omap_gpmc.o
 obj-$(CONFIG_NAND_OMAP_ELM) += omap_elm.o
 obj-$(CONFIG_NAND_PLAT) += nand_plat.o
 obj-$(CONFIG_NAND_DOCG4) += docg4.o
+obj-$(CONFIG_NAND_SUNXI) += sunxi_nand_common.o
+obj-$(CONFIG_NAND_SUNXI) += sunxi_nand_id.o
+ifdef CONFIG_SPL_BUILD
+obj-$(CONFIG_NAND_SUNXI) += sunxi_nand_spl.o
+else
+obj-$(CONFIG_NAND_SUNXI) += sunxi_nand.o
+obj-$(CONFIG_NAND_SUNXI) += sunxi_nand1k.o
+endif
 
 else  # minimal SPL drivers
 
diff --git a/drivers/mtd/nand/sunxi_nand.c b/drivers/mtd/nand/sunxi_nand.c
new file mode 100644
index 0000000..336bfaa
--- /dev/null
+++ b/drivers/mtd/nand/sunxi_nand.c
@@ -0,0 +1,610 @@
+/*
+ * sunxi_nand.c
+ *
+ * Copyright (C) 2013 Qiang Yu <yuq825@gmail.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "sunxi_nand.h"
+
+static int read_offset = 0, write_offset = 0;
+static int buffer_size = 8192 + 1024;
+static char write_buffer[8192 + 1024] __attribute__((aligned(4)));
+static char read_buffer[8192 + 1024] __attribute__((aligned(4)));
+static struct nand_ecclayout sunxi_ecclayout;
+static int program_column = -1, program_page = -1;
+
+static void print_nand_clock(void)
+{
+	struct sunxi_ccm_reg *const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	debug("============= nand clock ==============\n");
+	debug("nand_sclk_cfg=%08x ahb_gate0=%08x\n", 
+		  readl(&ccm->nand_sclk_cfg), readl(&ccm->ahb_gate0));
+}
+
+static void print_nand_gpio(void)
+{
+	struct sunxi_gpio *pio =
+	    &((struct sunxi_gpio_reg *)SUNXI_PIO_BASE)->gpio_bank[2];
+	debug("============= nand gpio ===============\n");
+	debug("cfg0=%08x cfg1=%08x cfg2=%08x\n", 
+		  readl(&pio->cfg[0]), readl(&pio->cfg[1]), readl(&pio->cfg[2]));
+}
+
+/////////////////////////////////////////////////////////////////
+// NFC
+//
+
+static void nfc_select_chip(struct mtd_info *mtd, int chip)
+{
+	uint32_t ctl;
+	// A10 has 8 CE pin to support 8 flash chips
+    ctl = readl(NFC_REG_CTL);
+    ctl &= ~NFC_CE_SEL;
+	ctl |= ((chip & 7) << 24);
+    writel(ctl, NFC_REG_CTL);
+}
+
+static void nfc_cmdfunc(struct mtd_info *mtd, unsigned command, int column,
+						int page_addr)
+{
+	int i;
+	uint32_t cfg = command;
+	int read_size, write_size, do_enable_ecc = 0;
+	int addr_cycle, wait_rb_flag, byte_count, sector_count;
+	addr_cycle = wait_rb_flag = byte_count = sector_count = 0;
+
+	//debug("command %x ...\n", command);
+	wait_cmdfifo_free();
+
+	// switch to AHB
+	writel(readl(NFC_REG_CTL) & ~NFC_RAM_METHOD, NFC_REG_CTL);
+
+	switch (command) {
+	case NAND_CMD_RESET:
+	case NAND_CMD_ERASE2:
+		break;
+	case NAND_CMD_READID:
+		addr_cycle = 1;
+		// read 8 byte ID
+		byte_count = 8;
+		break;
+	case NAND_CMD_PARAM:
+		addr_cycle = 1;
+		byte_count = 1024;
+		wait_rb_flag = 1;
+		break;
+	case NAND_CMD_RNDOUT:
+		addr_cycle = 2;
+		writel(0xE0, NFC_REG_RCMD_SET);
+		byte_count = mtd->oobsize;
+		cfg |= NFC_SEQ | NFC_SEND_CMD2;
+		wait_rb_flag = 1;
+		break;
+	case NAND_CMD_READOOB:
+	case NAND_CMD_READ0:
+		if (command == NAND_CMD_READOOB) {
+			cfg = NAND_CMD_READ0;
+			// sector num to read
+			sector_count = 1024 / 1024;
+			read_size = 1024;
+			// OOB offset
+			column += mtd->writesize;
+		}
+		else {
+			sector_count = mtd->writesize / 1024;
+			read_size = mtd->writesize;
+			do_enable_ecc = 1;
+			debug("cmdfunc read %d %d\n", column, page_addr);
+		}
+			
+		//access NFC internal RAM by DMA bus
+		writel(readl(NFC_REG_CTL) | NFC_RAM_METHOD, NFC_REG_CTL);
+		// if the size is smaller than NFC_REG_SECTOR_NUM, read command won't finish
+		// does that means the data read out (by DMA through random data output) hasn't finish?
+		_dma_config_start(0, NFC_REG_IO_DATA, (__u32)read_buffer, read_size);
+		addr_cycle = 5;
+		// RAM0 is 1K size
+		byte_count =1024;
+		wait_rb_flag = 1;
+		// 0x30 for 2nd cycle of read page
+		// 0x05+0xe0 is the random data output command
+		writel(0x00e00530, NFC_REG_RCMD_SET);
+		// NFC_SEND_CMD1 for the command 1nd cycle enable
+		// NFC_SEND_CMD2 for the command 2nd cycle enable
+		// NFC_SEND_CMD3 & NFC_SEND_CMD4 for NFC_READ_CMD0 & NFC_READ_CMD1
+		cfg |= NFC_SEND_CMD2 | NFC_DATA_SWAP_METHOD;
+		// 3 - ?
+		// 2 - page command
+		// 1 - spare command?
+		// 0 - normal command
+		cfg |= 2 << 30;
+		break;
+	case NAND_CMD_ERASE1:
+		addr_cycle = 3;
+		//debug("cmdfunc earse block %d\n", page_addr);
+		break;
+	case NAND_CMD_SEQIN:	
+		program_column = column;
+		program_page = page_addr;
+		write_offset = 0;
+		return;
+	case NAND_CMD_PAGEPROG:
+		cfg = NAND_CMD_SEQIN;
+		addr_cycle = 5;
+		column = program_column;
+		page_addr = program_page;
+		debug("cmdfunc pageprog: %d %d\n", column, page_addr);
+
+		// for write OOB
+		if (column == mtd->writesize) {
+			sector_count = 1024 /1024;
+			write_size = 1024;
+		}
+		else if (column == 0) {
+			sector_count = mtd->writesize / 1024;
+			do_enable_ecc = 1;
+			write_size = mtd->writesize;
+			for (i = 0; i < sector_count; i++)
+				writel(*((unsigned int *)(write_buffer + mtd->writesize) + i), NFC_REG_USER_DATA(i));
+		}
+		else {
+			error("program unsupported column %d %d\n", column, page_addr);
+			return;
+		}
+
+		//access NFC internal RAM by DMA bus
+		writel(readl(NFC_REG_CTL) | NFC_RAM_METHOD, NFC_REG_CTL);
+		_dma_config_start(1, (__u32)write_buffer, NFC_REG_IO_DATA, write_size);
+		// RAM0 is 1K size
+		byte_count =1024;
+		writel(0x00008510, NFC_REG_WCMD_SET);
+		cfg |= NFC_SEND_CMD2 | NFC_DATA_SWAP_METHOD | NFC_ACCESS_DIR;
+		cfg |= 2 << 30;
+		if (column != 0) {
+			debug("cmdfunc program %d %d with %x %x %x\n", column, page_addr, 
+					 write_buffer[0], write_buffer[1], write_buffer[2]);
+		}
+		break;
+	case NAND_CMD_STATUS:
+		byte_count = 1;
+		break;
+	default:
+		error("unknown command\n");
+		return;
+	}
+
+	// address cycle
+	if (addr_cycle) {
+		uint32_t low = 0;
+		uint32_t high = 0;
+		switch (addr_cycle) {
+		case 2:
+			low = column & 0xffff;
+			break;
+		case 3:
+			low = page_addr & 0xffffff;
+			break;
+		case 5:
+			high = (page_addr >> 16) & 0xff;
+		case 4:
+			low = (column & 0xffff) | (page_addr << 16);
+			break;
+		}
+		writel(low, NFC_REG_ADDR_LOW);
+		writel(high, NFC_REG_ADDR_HIGH);
+		cfg |= NFC_SEND_ADR;
+		cfg |= ((addr_cycle - 1) << 16);
+	}
+
+	// command will wait until the RB ready to mark finish?
+	if (wait_rb_flag)
+		cfg |= NFC_WAIT_FLAG;
+
+	// will fetch data
+	if (byte_count) {
+		cfg |= NFC_DATA_TRANS;
+		writel(byte_count, NFC_REG_CNT);
+	}
+
+	// set sectors
+	if (sector_count)
+		writel(sector_count, NFC_REG_SECTOR_NUM);
+
+	// enable ecc
+	if (do_enable_ecc)
+		enable_ecc(1);
+
+	// send command
+	cfg |= NFC_SEND_CMD1;
+	writel(cfg, NFC_REG_CMD);
+
+	switch (command) {
+	case NAND_CMD_READ0:
+	case NAND_CMD_READOOB:
+	case NAND_CMD_PAGEPROG:
+		_wait_dma_end();
+		break;
+	}
+
+	// wait command send complete
+	wait_cmdfifo_free();
+	wait_cmd_finish();
+
+	// reset will wait for RB ready
+	switch (command) {
+	case NAND_CMD_RESET:
+		// wait rb0 ready
+		select_rb(0);
+		while (!check_rb_ready(0));
+		// wait rb1 ready
+		select_rb(1);
+		while (!check_rb_ready(1));
+		// select rb 0 back
+		select_rb(0);
+		break;
+	case NAND_CMD_READ0:
+		for (i = 0; i < sector_count; i++)
+			*((unsigned int *)(read_buffer + mtd->writesize) + i) = readl(NFC_REG_USER_DATA(i));
+		break;
+	}
+
+	if (do_enable_ecc)
+		disable_ecc();
+
+	//debug("done\n");
+
+	// read write offset
+	read_offset = 0;
+}
+
+static uint8_t nfc_read_byte(struct mtd_info *mtd)
+{
+	return readb(NFC_RAM0_BASE + read_offset++);
+}
+
+static int nfc_dev_ready(struct mtd_info *mtd)
+{
+	return check_rb_ready(0);
+}
+
+static void nfc_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	if (write_offset + len > buffer_size) {
+		error("write too much offset=%d len=%d buffer size=%d\n",
+				 write_offset, len, buffer_size);
+		return;
+	}
+	memcpy(write_buffer + write_offset, buf, len);
+	write_offset += len;
+}
+
+static void nfc_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	if (read_offset + len > buffer_size) {
+		error("read too much offset=%d len=%d buffer size=%d\n", 
+				 read_offset, len, buffer_size);
+		return;
+	}
+	memcpy(buf, read_buffer + read_offset, len);
+	read_offset += len;
+}
+
+static int get_chip_status(struct mtd_info *mtd)
+{
+	struct nand_chip *nand = mtd->priv;
+	nand->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
+	return nand->read_byte(mtd);
+}
+
+// For erase and program command to wait for chip ready
+static int nfc_wait(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	while (!check_rb_ready(0));
+	return get_chip_status(mtd);
+}
+
+static void nfc_ecc_hwctl(struct mtd_info *mtd, int mode)
+{
+
+}
+
+static int nfc_ecc_calculate(struct mtd_info *mtd, const uint8_t *dat, uint8_t *ecc_code)
+{
+	return 0;
+}
+
+static int nfc_ecc_correct(struct mtd_info *mtd, uint8_t *dat, uint8_t *read_ecc, uint8_t *calc_ecc)
+{
+	return check_ecc(mtd->writesize / 1024);
+}
+
+//////////////////////////////////////////////////////////////////////////////////
+// 1K mode for SPL read/write
+
+struct save_1k_mode {
+	uint32_t ctl;
+	uint32_t ecc_ctl;
+	uint32_t spare_area;
+};
+
+static void enter_1k_mode(struct save_1k_mode *save)
+{
+	uint32_t ctl;
+
+	ctl = readl(NFC_REG_CTL);
+	save->ctl = ctl;
+	ctl &= ~NFC_PAGE_SIZE;
+	writel(ctl, NFC_REG_CTL);
+	
+	ctl = readl(NFC_REG_ECC_CTL);
+	save->ecc_ctl = ctl;
+	set_ecc_mode(8);
+
+	ctl = readl(NFC_REG_SPARE_AREA);
+	save->spare_area = ctl;
+	writel(1024, NFC_REG_SPARE_AREA);
+}
+
+static void exit_1k_mode(struct save_1k_mode *save)
+{
+	writel(save->ctl, NFC_REG_CTL);
+	writel(save->ecc_ctl, NFC_REG_ECC_CTL);
+	writel(save->spare_area, NFC_REG_SPARE_AREA);
+}
+
+void nfc_read_page1k(uint32_t page_addr, void *buff)
+{
+	struct save_1k_mode save;
+	uint32_t cfg = NAND_CMD_READ0 | NFC_SEQ | NFC_SEND_CMD1 | NFC_DATA_TRANS | NFC_SEND_ADR | 
+		NFC_SEND_CMD2 | ((5 - 1) << 16) | NFC_WAIT_FLAG | NFC_DATA_SWAP_METHOD | (2 << 30);
+
+	nfc_select_chip(NULL, 0);
+
+	wait_cmdfifo_free();
+
+	enter_1k_mode(&save);
+
+	writel(readl(NFC_REG_CTL) | NFC_RAM_METHOD, NFC_REG_CTL);
+	_dma_config_start(0, NFC_REG_IO_DATA, (uint32_t)buff, 1024);
+
+	writel(page_addr << 16, NFC_REG_ADDR_LOW);
+	writel(page_addr >> 16, NFC_REG_ADDR_HIGH);
+	writel(1024, NFC_REG_CNT);
+	writel(0x00e00530, NFC_REG_RCMD_SET);
+	writel(1, NFC_REG_SECTOR_NUM);
+
+	enable_random();
+
+	enable_ecc(1);
+
+	writel(cfg, NFC_REG_CMD);
+
+	_wait_dma_end();
+	wait_cmdfifo_free();
+	wait_cmd_finish();
+
+	disable_ecc();
+	check_ecc(1);
+
+	disable_random();
+
+	exit_1k_mode(&save);
+
+	nfc_select_chip(NULL, -1);
+}
+
+void nfc_write_page1k(uint32_t page_addr, void *buff)
+{
+	struct save_1k_mode save;
+	uint32_t cfg = NAND_CMD_SEQIN | NFC_SEQ | NFC_SEND_CMD1 | NFC_DATA_TRANS | NFC_SEND_ADR | 
+		NFC_SEND_CMD2 | ((5 - 1) << 16) | NFC_WAIT_FLAG | NFC_DATA_SWAP_METHOD | NFC_ACCESS_DIR | 
+		(2 << 30);
+
+	nfc_select_chip(NULL, 0);
+
+	wait_cmdfifo_free();
+
+	enter_1k_mode(&save);
+
+	writel(readl(NFC_REG_CTL) | NFC_RAM_METHOD, NFC_REG_CTL);
+	_dma_config_start(1, (uint32_t)buff, NFC_REG_IO_DATA, 1024);
+
+	writel(page_addr << 16, NFC_REG_ADDR_LOW);
+	writel(page_addr >> 16, NFC_REG_ADDR_HIGH);
+	writel(1024, NFC_REG_CNT);
+	writel(0x00008510, NFC_REG_WCMD_SET);
+	writel(1, NFC_REG_SECTOR_NUM);
+
+	enable_random();
+
+	enable_ecc(1);
+
+	writel(cfg, NFC_REG_CMD);
+
+	_wait_dma_end();
+	wait_cmdfifo_free();
+	wait_cmd_finish();
+
+	disable_ecc();
+
+	disable_random();
+
+	exit_1k_mode(&save);
+
+	nfc_select_chip(NULL, -1);
+}
+
+//////////////////////////////////////////////////////////////////////////////////////
+
+static void print_nand_nfc(void)
+{
+	debug("=============== nand bfc ===============\n");
+	debug("CTL=%08x ST=%08x INT=%08x TIMING_CTL=%08x TIMING_CFG=%08x\n",
+		  readl(NFC_REG_CTL), readl(NFC_REG_ST), readl(NFC_REG_INT), 
+		  readl(NFC_REG_TIMING_CTL), readl(NFC_REG_TIMING_CFG));
+	debug("ADDR_LOW=%08x ADDR_HIGH=%08x SECTOR_NUM=%08x CNT=%08x\n",
+		  readl(NFC_REG_ADDR_LOW), readl(NFC_REG_ADDR_HIGH), 
+		  readl(NFC_REG_SECTOR_NUM), readl(NFC_REG_CNT));
+	debug("CMD=%08x RCMD=%08x WCMD=%08x ECC_CTL=%08x ECC_ST=%08x\n",
+		  readl(NFC_REG_CMD), readl(NFC_REG_RCMD_SET), readl(NFC_REG_WCMD_SET),
+		  readl(NFC_REG_ECC_CTL), readl(NFC_REG_ECC_ST));
+	debug("SPARE_AREA=%08x\n", readl(NFC_REG_SPARE_AREA));
+}
+
+static void print_nand_regs(void)
+{
+	print_nand_clock();
+	print_nand_gpio();
+	print_nand_nfc();
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	u32 ctl;
+	int i, j;
+	uint8_t id[8];
+	struct nand_chip_param *nand_chip_param, *chip_param = NULL;
+
+	debug("board_nand_init start\n");
+
+	// set init clock
+	sunxi_nand_set_clock(NAND_MAX_CLOCK);
+
+	// set gpio
+	sunxi_nand_set_gpio();
+
+	//print_nand_regs();
+
+	// reset NFC
+	ctl = readl(NFC_REG_CTL);
+	ctl |= NFC_RESET;
+	writel(ctl, NFC_REG_CTL);
+	while(readl(NFC_REG_CTL) & NFC_RESET);
+
+	// enable NFC
+	ctl = NFC_EN;
+	writel(ctl, NFC_REG_CTL);
+
+	// serial_access_mode = 1
+	ctl = (1 << 8);
+	writel(ctl, NFC_REG_TIMING_CTL);
+
+	// reset nand chip
+	nfc_cmdfunc(NULL, NAND_CMD_RESET, -1, -1);
+	// read nand chip id
+	nfc_cmdfunc(NULL, NAND_CMD_READID, 0, -1);
+	for (i = 0; i < 8; i++)
+		id[i] = nfc_read_byte(NULL);
+
+	// find chip
+	nand_chip_param = sunxi_get_nand_chip_param(id[0]);
+	for (i = 0; nand_chip_param[i].id_len; i++) {
+		int find = 1;
+		for (j = 0; j < nand_chip_param[i].id_len; j++) {
+			if (id[j] != nand_chip_param[i].id[j]) {
+				find = 0;
+				break;
+			}
+		}
+		if (find) {
+			chip_param = &nand_chip_param[i];
+			debug("find nand chip in sunxi database\n");
+			break;
+		}
+	}
+
+	// not find
+	if (chip_param == NULL) {
+		error("can't find nand chip in sunxi database\n");
+		return -ENODEV;
+	}
+
+	// set final NFC clock freq
+	if (chip_param->clock_freq > 30)
+		chip_param->clock_freq = 30;
+	sunxi_nand_set_clock((int)chip_param->clock_freq * 1000000);
+	debug("set final clock freq to %dMHz\n", (int)chip_param->clock_freq);
+
+	// disable interrupt
+	writel(0, NFC_REG_INT);
+	// clear interrupt
+	writel(readl(NFC_REG_ST), NFC_REG_ST);
+
+	// set ECC mode
+	ctl = readl(NFC_REG_ECC_CTL);
+	ctl &= ~NFC_ECC_MODE;
+	ctl |= (unsigned int)chip_param->ecc_mode << NFC_ECC_MODE_SHIFT;
+	writel(ctl, NFC_REG_ECC_CTL);
+
+	// enable NFC
+	ctl = NFC_EN;
+
+	// Page size
+	if (chip_param->page_shift > 14 || chip_param->page_shift < 10) {
+		error("Flash chip page shift out of range %d\n", (int)chip_param->page_shift);
+		return -EINVAL;
+	}
+	// 0 for 1K
+	ctl |= (((int)chip_param->page_shift - 10) & 0xf) << 8;
+	writel(ctl, NFC_REG_CTL);
+
+	writel(0xff, NFC_REG_TIMING_CFG);
+	writel(1U << chip_param->page_shift, NFC_REG_SPARE_AREA);
+
+	// disable random
+	disable_random();
+
+	// setup ECC layout
+	sunxi_ecclayout.eccbytes = 0;
+	sunxi_ecclayout.oobavail = (1U << chip_param->page_shift) / 1024 * 4 - 2;
+	sunxi_ecclayout.oobfree->offset = 1;
+	sunxi_ecclayout.oobfree->length = (1U << chip_param->page_shift) / 1024 * 4 - 2;
+	nand->ecc.layout = &sunxi_ecclayout;
+	nand->ecc.size = (1U << chip_param->page_shift);
+	nand->ecc.bytes = 0;
+
+	// set buffer size
+	buffer_size = (1U << chip_param->page_shift) + 1024;
+
+	// setup DMA
+	dma_hdle = DMA_Request(DMAC_DMATYPE_DEDICATED);
+	if (dma_hdle == 0) {
+		error("request DMA fail\n");
+		return -ENODEV;
+	}
+	print_nand_dma(dma_hdle);
+
+	nand->ecc.mode = NAND_ECC_HW;
+	nand->ecc.hwctl = nfc_ecc_hwctl;
+	nand->ecc.calculate = nfc_ecc_calculate;
+	nand->ecc.correct = nfc_ecc_correct;
+	nand->select_chip = nfc_select_chip;
+	nand->dev_ready = nfc_dev_ready;
+	nand->cmdfunc = nfc_cmdfunc;
+	nand->read_byte = nfc_read_byte;
+	nand->read_buf = nfc_read_buf;
+	nand->write_buf = nfc_write_buf;
+	nand->waitfunc = nfc_wait;
+	nand->bbt_options = NAND_BBT_USE_FLASH;
+
+	debug("board_nand_init finish\n");
+
+	//print_nand_regs();
+
+	return 0;
+}
+
diff --git a/drivers/mtd/nand/sunxi_nand.h b/drivers/mtd/nand/sunxi_nand.h
new file mode 100644
index 0000000..666b8e6
--- /dev/null
+++ b/drivers/mtd/nand/sunxi_nand.h
@@ -0,0 +1,206 @@
+/*
+ * sunxi_nand.h
+ *
+ * Copyright (C) 2013 Qiang Yu <yuq825@gmail.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _SUNXI_NAND_H
+#define _SUNXI_NAND_H
+
+#include <common.h>
+#include <nand.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch/dma.h>
+#include <asm/arch/clock.h>
+
+#define NFC_REG_CTL               0x01c03000
+#define NFC_REG_ST                0x01c03004
+#define NFC_REG_INT               0x01c03008
+#define NFC_REG_TIMING_CTL        0x01c0300c
+#define NFC_REG_TIMING_CFG        0x01c03010
+#define NFC_REG_ADDR_LOW          0x01c03014
+#define NFC_REG_ADDR_HIGH         0x01c03018
+#define NFC_REG_SECTOR_NUM        0x01c0301c
+#define NFC_REG_CNT		          0x01c03020
+#define NFC_REG_CMD		          0x01c03024
+#define NFC_REG_RCMD_SET          0x01c03028
+#define NFC_REG_WCMD_SET          0x01c0302c
+#define NFC_REG_IO_DATA           0x01c03030
+#define NFC_REG_ECC_CTL           0x01c03034
+#define NFC_REG_ECC_ST            0x01c03038
+#define NFC_REG_DEBUG             0x01c0303c
+#define NFC_REG_ECC_CNT0          0x01c03040
+#define NFC_REG_ECC_CNT1          0x01c03044
+#define NFC_REG_ECC_CNT2          0x01c03048
+#define NFC_REG_ECC_CNT3          0x01c0304c
+#define NFC_REG_USER_DATA_BASE    0x01c03050
+#define NFC_REG_USER_DATA(i)      ( NFC_REG_USER_DATA_BASE + 4 * i )
+#define NFC_REG_SPARE_AREA        0x01c030a0
+#define NFC_RAM0_BASE             0x01c03400
+
+/*define bit use in NFC_CTL*/
+#define NFC_EN					(1 << 0)
+#define NFC_RESET				(1 << 1)
+#define NFC_BUS_WIDYH			(1 << 2)
+#define NFC_RB_SEL				(1 << 3)
+#define NFC_CE_SEL				(7 << 24)
+#define NFC_CE_CTL				(1 << 6)
+#define NFC_CE_CTL1				(1 << 7)
+#define NFC_PAGE_SIZE			(0xf << 8)
+#define NFC_SAM					(1 << 12)
+#define NFC_RAM_METHOD			(1 << 14)
+#define NFC_DEBUG_CTL			(1 << 31)
+
+/*define bit use in NFC_ST*/
+#define NFC_RB_B2R				(1 << 0)
+#define NFC_CMD_INT_FLAG		(1 << 1)
+#define NFC_DMA_INT_FLAG		(1 << 2)
+#define NFC_CMD_FIFO_STATUS		(1 << 3)
+#define NFC_STA					(1 << 4)
+#define NFC_NATCH_INT_FLAG		(1 << 5)
+#define NFC_RB_STATE0			(1 << 8)
+#define NFC_RB_STATE1			(1 << 9)
+#define NFC_RB_STATE2			(1 << 10)
+#define NFC_RB_STATE3			(1 << 11)
+
+/*define bit use in NFC_INT*/
+#define NFC_B2R_INT_ENABLE		(1 << 0)
+#define NFC_CMD_INT_ENABLE		(1 << 1)
+#define NFC_DMA_INT_ENABLE		(1 << 2)
+
+
+/*define bit use in NFC_CMD*/
+#define NFC_CMD_LOW_BYTE		(0xff << 0)
+#define NFC_CMD_HIGH_BYTE		(0xff << 8)
+#define NFC_ADR_NUM				(0x7 << 16)
+#define NFC_SEND_ADR			(1 << 19)
+#define NFC_ACCESS_DIR			(1 << 20)
+#define NFC_DATA_TRANS			(1 << 21)
+#define NFC_SEND_CMD1			(1 << 22)
+#define NFC_WAIT_FLAG			(1 << 23)
+#define NFC_SEND_CMD2			(1 << 24)
+#define NFC_SEQ					(1 << 25)
+#define NFC_DATA_SWAP_METHOD	(1 << 26)
+#define NFC_ROW_AUTO_INC		(1 << 27)
+#define NFC_SEND_CMD3           (1 << 28)
+#define NFC_SEND_CMD4           (1 << 29)
+#define NFC_CMD_TYPE			(3 << 30)
+
+/* define bit use in NFC_RCMD_SET*/
+#define NFC_READ_CMD			(0xff<< 0)
+#define NFC_RANDOM_READ_CMD0 	(0xff << 8)
+#define NFC_RANDOM_READ_CMD1 	(0xff << 16)
+
+/*define bit use in NFC_WCMD_SET*/
+#define NFC_PROGRAM_CMD			(0xff << 0)
+#define NFC_RANDOM_WRITE_CMD	(0xff << 8)
+#define NFC_READ_CMD0			(0xff << 16)
+#define NFC_READ_CMD1	        (0xff << 24)
+
+/*define bit use in NFC_ECC_CTL*/
+#define NFC_ECC_EN				(1 << 0)
+#define NFC_ECC_PIPELINE		(1 << 3)
+#define NFC_ECC_EXCEPTION       (1 << 4)
+#define NFC_ECC_BLOCK_SIZE		(1 << 5)
+#define NFC_RANDOM_EN           (1 << 9 )
+#define NFC_RANDOM_DIRECTION    (1 << 10 )
+#define NFC_ECC_MODE_SHIFT      12
+#define NFC_ECC_MODE			(0xf << NFC_ECC_MODE_SHIFT)
+#define NFC_RANDOM_SEED         (0x7fff << 16)
+
+#define NFC_IRQ_MAJOR		    13
+/*cmd flag bit*/
+#define NFC_PAGE_MODE  			0x1
+#define NFC_NORMAL_MODE  		0x0
+
+#define NFC_DATA_FETCH 			0x1
+#define NFC_NO_DATA_FETCH 		0x0
+#define NFC_MAIN_DATA_FETCH 	0x1
+#define NFC_SPARE_DATA_FETCH	0X0
+#define NFC_WAIT_RB				0x1
+#define NFC_NO_WAIT_RB			0x0
+#define NFC_IGNORE				0x0
+
+#define NFC_INT_RB				0
+#define NFC_INT_CMD				1
+#define NFC_INT_DMA				2
+#define NFC_INT_BATCh			5
+
+struct nand_chip_param {
+	unsigned char id[8];
+	unsigned char id_len;
+	unsigned char page_shift;
+	unsigned char page_per_block_shift;
+	unsigned char clock_freq; //the highest access frequence of the nand flash chip, based on MHz
+	unsigned char ecc_mode;   //the Ecc Mode for the nand flash chip, 0: bch-16, 1:bch-28, 2:bch_32
+};
+
+struct nand_chip_param *sunxi_get_nand_chip_param(unsigned char mf);
+
+extern int dma_hdle;
+
+#define NAND_MAX_CLOCK (10 * 1000000)
+
+void sunxi_nand_set_clock(int hz);
+void sunxi_nand_set_gpio(void);
+
+/////////////////////////////////////////////////////////////////
+// Utils
+//
+
+static inline void wait_cmdfifo_free(void)
+{
+	int timeout = 0xffff;
+	while ((timeout--) && (readl(NFC_REG_ST) & NFC_CMD_FIFO_STATUS));
+	if (timeout <= 0) {
+		error("wait_cmdfifo_free timeout\n");
+	}
+}
+
+static inline void wait_cmd_finish(void)
+{
+	int timeout = 0xffff;
+	while((timeout--) && !(readl(NFC_REG_ST) & NFC_CMD_INT_FLAG));
+	if (timeout <= 0) {
+		error("wait_cmd_finish timeout\n");
+		return;
+	}
+	writel(NFC_CMD_INT_FLAG, NFC_REG_ST);
+}
+
+// 1 for ready, 0 for not ready
+static inline int check_rb_ready(int rb)
+{
+	return (readl(NFC_REG_ST) & (NFC_RB_STATE0 << (rb & 0x3))) ? 1 : 0;
+}
+
+void select_rb(int rb);
+void enable_random(void);
+void disable_random(void);
+void enable_ecc(int pipline);
+int check_ecc(int eblock_cnt);
+void set_ecc_mode(int mode);
+void disable_ecc(void);
+void _dma_config_start(__u32 rw, __u32 src_addr, __u32 dst_addr, __u32 len);
+__s32 _wait_dma_end(void);
+
+void nfc_read_page1k(uint32_t page_addr, void *buff);
+void nfc_write_page1k(uint32_t page_addr, void *buff);
+
+#endif
+
diff --git a/drivers/mtd/nand/sunxi_nand1k.c b/drivers/mtd/nand/sunxi_nand1k.c
new file mode 100644
index 0000000..afb2167
--- /dev/null
+++ b/drivers/mtd/nand/sunxi_nand1k.c
@@ -0,0 +1,91 @@
+/*
+ * sunxi_nand_common.c
+ *
+ * Copyright (C) 2013 Qiang Yu <yuq825@gmail.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "sunxi_nand.h"
+
+static char rw_buff[1024];
+
+int nand1k_read(char *buff, loff_t offs, size_t count)
+{
+	uint32_t len, page, offset;
+	size_t size = 0;
+
+	debug("nand1k read off=%llx count=%x\n", offs, count);
+
+	if (offs > 128 * 1024 || offs < 0 || 
+		count < 0 || count > 128 * 1024 || 
+		offs + count > 128 * 1024) {
+		error("nand1k is restricted to access the first 128 1K pages\n");
+		return -EINVAL;
+	}
+
+	while (size < count) {
+		page = offs / 1024;
+		offset = offs % 1024;
+		len = 1024 - offset;
+		if (len > count - size)
+			len = count - size;
+
+		nfc_read_page1k(page, rw_buff);
+
+		memcpy(buff, rw_buff + offset, len);
+
+		size += len;
+		offs += len;
+		buff += len;
+	}
+
+    return size;
+}
+
+int nand1k_write(const char *buff, loff_t offs, size_t count)
+{
+	uint32_t ret;
+	size_t size = 0;
+
+	debug("nand1k write off=%llx count=%x\n", offs, count);
+
+	if (offs > 128 * 1024 || offs < 0 || 
+		count < 0 || count > 128 * 1024 || 
+		offs + count > 128 * 1024) {
+		error("nand1k is restricted to access the first 128 1K pages\n");
+		return -EINVAL;
+	}
+
+	if ((offs & (1024 - 1)) || (count & (1024 - 1))) {
+		error("nand1k can't write non-1K-aligned data\n");
+		return -EINVAL;
+	}
+
+	while (size < count) {
+		memcpy(rw_buff, buff, 1024);
+
+		nfc_write_page1k(offs / 1024, rw_buff);
+		
+		size += 1024;
+		offs += 1024;
+		buff += 1024;
+	}
+
+    return size;
+}
+
+
+
+
diff --git a/drivers/mtd/nand/sunxi_nand_common.c b/drivers/mtd/nand/sunxi_nand_common.c
new file mode 100644
index 0000000..d2f4b3d
--- /dev/null
+++ b/drivers/mtd/nand/sunxi_nand_common.c
@@ -0,0 +1,257 @@
+/*
+ * sunxi_nand_common.c
+ *
+ * Copyright (C) 2013 Qiang Yu <yuq825@gmail.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "sunxi_nand.h"
+
+int dma_hdle;
+
+void sunxi_nand_set_clock(int hz)
+{
+	struct sunxi_ccm_reg *const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	int clock = clock_get_pll5();
+	int edo_clk = hz * 2;
+	int div_n = 0, div_m;
+	int nand_clk_divid_ratio = clock / edo_clk;
+
+	if (clock % edo_clk)
+		nand_clk_divid_ratio++;
+	for (div_m = nand_clk_divid_ratio; div_m > 16 && div_n < 3; div_n++) {
+		if (div_m % 2)
+			div_m++;
+		div_m >>= 1;
+	}
+	div_m--;
+	if (div_m > 15)
+		div_m = 15;	/* Overflow */
+
+	/* nand clock source is PLL5 */
+	/* TODO: define proper clock sources for NAND reg */
+	clrsetbits_le32(&ccm->nand_sclk_cfg, 3 << 24, 2 << 24); /* 2 = PLL5 */
+	clrsetbits_le32(&ccm->nand_sclk_cfg, 3 << 16, div_n << 16);
+	clrsetbits_le32(&ccm->nand_sclk_cfg, 0xf << 0, div_m << 0);
+	setbits_le32(&ccm->nand_sclk_cfg, (1 << 31));
+	/* open clock for nand and DMA*/
+	setbits_le32(&ccm->ahb_gate0, (1 << AHB_GATE_OFFSET_NAND) | (1 << AHB_GATE_OFFSET_DMA));
+	debug("NAND Clock: PLL5=%dHz, divid_ratio=%d, n=%d m=%d, clock=%dHz (target %dHz\n", 
+		  clock, nand_clk_divid_ratio, div_n, div_m, (clock>>div_n)/(div_m+1), hz);
+}
+
+void sunxi_nand_set_gpio(void)
+{
+	struct sunxi_gpio *pio =
+	    &((struct sunxi_gpio_reg *)SUNXI_PIO_BASE)->gpio_bank[2];
+	writel(0x22222222, &pio->cfg[0]);
+	writel(0x22222222, &pio->cfg[1]);
+	writel(0x22222222, &pio->cfg[2]);
+}
+
+void select_rb(int rb)
+{
+	uint32_t ctl;
+	// A10 has 2 RB pin
+	ctl = readl(NFC_REG_CTL);
+	ctl &= ~NFC_RB_SEL;
+	ctl |= ((rb & 0x1) << 3);
+	writel(ctl, NFC_REG_CTL);
+}
+
+void enable_random(void)
+{
+	uint32_t ctl;
+	ctl = readl(NFC_REG_ECC_CTL);
+	ctl |= NFC_RANDOM_EN;
+	ctl &= ~NFC_RANDOM_DIRECTION;
+	ctl &= ~NFC_RANDOM_SEED;
+	ctl |= (0x4a80 << 16);
+	writel(ctl, NFC_REG_ECC_CTL);
+}
+
+void disable_random(void)
+{
+	uint32_t ctl;
+	ctl = readl(NFC_REG_ECC_CTL);
+	ctl &= ~NFC_RANDOM_EN;
+	writel(ctl, NFC_REG_ECC_CTL);
+}
+
+void enable_ecc(int pipline)
+{
+	uint32_t cfg = readl(NFC_REG_ECC_CTL);
+	if (pipline)
+		cfg |= NFC_ECC_PIPELINE;
+	else
+		cfg &= (~NFC_ECC_PIPELINE) & 0xffffffff;
+
+	// if random open, disable exception
+	if(cfg & (1 << 9))
+	    cfg &= ~(0x1 << 4);
+	else
+	    cfg |= 1 << 4;
+
+	//cfg |= (1 << 1); 16 bit ecc
+
+	cfg |= NFC_ECC_EN;
+	writel(cfg, NFC_REG_ECC_CTL);
+}
+
+int check_ecc(int eblock_cnt)
+{
+	int i;
+    int ecc_mode;
+	int max_ecc_bit_cnt = 16;
+	int cfg, corrected = 0;
+
+	ecc_mode = (readl(NFC_REG_ECC_CTL) & NFC_ECC_MODE) >> NFC_ECC_MODE_SHIFT;
+	if(ecc_mode == 0)
+		max_ecc_bit_cnt = 16;
+	if(ecc_mode == 1)
+		max_ecc_bit_cnt = 24;
+	if(ecc_mode == 2)
+		max_ecc_bit_cnt = 28;
+	if(ecc_mode == 3)
+		max_ecc_bit_cnt = 32;
+	if(ecc_mode == 4)
+		max_ecc_bit_cnt = 40;
+	if(ecc_mode == 5)
+		max_ecc_bit_cnt = 48;
+	if(ecc_mode == 6)
+		max_ecc_bit_cnt = 56;
+    if(ecc_mode == 7)
+		max_ecc_bit_cnt = 60;
+    if(ecc_mode == 8)
+		max_ecc_bit_cnt = 64;
+
+	//check ecc error
+	cfg = readl(NFC_REG_ECC_ST) & 0xffff;
+	for (i = 0; i < eblock_cnt; i++) {
+		if (cfg & (1<<i)) {
+			error("ECC too many error at %d\n", i);
+			return -1;
+		}
+	}
+
+	//check ecc limit
+	for (i = 0; i < eblock_cnt; i += 4) {
+		int j, n = (eblock_cnt - i) < 4 ? (eblock_cnt - i) : 4;
+		cfg = readl(NFC_REG_ECC_CNT0 + i);
+		for (j = 0; j < n; j++, cfg >>= 8) {
+			int bits = cfg & 0xff;
+			if (bits >= max_ecc_bit_cnt - 4) {
+				debug("ECC limit %d/%d\n", bits, max_ecc_bit_cnt);
+				corrected++;
+			}
+		}
+	}
+
+	return corrected;
+}
+
+void set_ecc_mode(int mode)
+{
+	uint32_t ctl;
+	ctl = readl(NFC_REG_ECC_CTL);
+	ctl &= ~NFC_ECC_MODE;
+	ctl |= mode << NFC_ECC_MODE_SHIFT;
+	writel(ctl, NFC_REG_ECC_CTL);
+}
+
+void disable_ecc(void)
+{
+	uint32_t cfg = readl(NFC_REG_ECC_CTL);
+	cfg &= (~NFC_ECC_EN) & 0xffffffff;
+	writel(cfg, NFC_REG_ECC_CTL);
+}
+
+void _dma_config_start(__u32 rw, __u32 src_addr, __u32 dst_addr, __u32 len)
+{
+	__dma_setting_t   dma_param;
+
+	if(rw)  //write
+	{
+		if(src_addr & 0xC0000000) //DRAM
+			dma_param.cfg.src_drq_type = DMAC_CFG_SRC_TYPE_D_SDRAM;
+		else  //SRAM
+			dma_param.cfg.src_drq_type = DMAC_CFG_SRC_TYPE_D_SRAM;
+		dma_param.cfg.src_addr_type = DMAC_CFG_SRC_ADDR_TYPE_LINEAR_MODE;  //linemode
+		dma_param.cfg.src_burst_length = DMAC_CFG_SRC_4_BURST;  //burst mode
+		dma_param.cfg.src_data_width = DMAC_CFG_SRC_DATA_WIDTH_32BIT;  //32bit
+
+		dma_param.cfg.dst_drq_type = DMAC_CFG_DEST_TYPE_NFC;
+		dma_param.cfg.dst_addr_type = DMAC_CFG_DEST_ADDR_TYPE_IO_MODE; //IO mode
+		dma_param.cfg.dst_burst_length = DMAC_CFG_DEST_4_BURST; // burst mode
+		dma_param.cfg.dst_data_width = DMAC_CFG_DEST_DATA_WIDTH_32BIT; //32 bit
+
+		dma_param.cfg.wait_state = DMAC_CFG_WAIT_1_DMA_CLOCK; // invalid value
+		dma_param.cfg.continuous_mode = DMAC_CFG_CONTINUOUS_DISABLE; //no continous
+
+		dma_param.cmt_blk_cnt =  0x7f077f07; //commit register
+
+	}
+	else //read
+	{
+		dma_param.cfg.src_drq_type = DMAC_CFG_SRC_TYPE_NFC;
+		dma_param.cfg.src_addr_type = DMAC_CFG_SRC_ADDR_TYPE_IO_MODE;  //IO mode
+		dma_param.cfg.src_burst_length = DMAC_CFG_SRC_4_BURST;  //burst mode
+		dma_param.cfg.src_data_width = DMAC_CFG_SRC_DATA_WIDTH_32BIT;  //32bit
+
+		if(dst_addr & 0xC0000000) //DRAM
+			dma_param.cfg.dst_drq_type = DMAC_CFG_DEST_TYPE_D_SDRAM;
+		else  //SRAM
+			dma_param.cfg.dst_drq_type = DMAC_CFG_DEST_TYPE_D_SRAM;
+		dma_param.cfg.dst_addr_type = DMAC_CFG_DEST_ADDR_TYPE_LINEAR_MODE; //line mode
+		dma_param.cfg.dst_burst_length = DMAC_CFG_DEST_4_BURST; // burst mode
+		dma_param.cfg.dst_data_width = DMAC_CFG_DEST_DATA_WIDTH_32BIT; //32 bit
+
+		dma_param.cfg.wait_state = DMAC_CFG_WAIT_1_DMA_CLOCK; // invalid value
+		dma_param.cfg.continuous_mode = DMAC_CFG_CONTINUOUS_DISABLE; //no continous
+
+		dma_param.cmt_blk_cnt =  0x7f077f07; //commit register
+	}
+
+	DMA_Setting(dma_hdle, (void *)&dma_param);
+
+	if (rw) {
+		debug("write flush src\n");
+		flush_cache(src_addr, len);
+	}
+	else {
+		debug("read flush dst\n");
+		flush_cache(dst_addr, len);
+	}
+
+	DMA_Start(dma_hdle, src_addr, dst_addr, len);
+}
+
+
+__s32 _wait_dma_end(void)
+{
+	__s32 timeout = 0xffff;
+
+	while ((timeout--) && DMA_QueryStatus(dma_hdle));
+	if (timeout <= 0)
+		return -1;
+
+	return 0;
+}
+
+
+
+
+
diff --git a/drivers/mtd/nand/sunxi_nand_id.c b/drivers/mtd/nand/sunxi_nand_id.c
new file mode 100644
index 0000000..a936dc0
--- /dev/null
+++ b/drivers/mtd/nand/sunxi_nand_id.c
@@ -0,0 +1,278 @@
+/*
+ * sunxi_nand_id.h
+ *
+ * Copyright (C) 2013 Qiang Yu <yuq825@gmail.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "sunxi_nand.h"
+
+//==============================================================================
+//============================ SAMSUNG NAND FLASH ==============================
+//==============================================================================
+static struct nand_chip_param samsung_chip_param[] = {
+	// id, id_len, page_shift, page_per_block_shift, clock_freq, ecc_mode
+	//----------------------------------------------------------------------------------------------
+    { {0xec, 0xf1, 0xff, 0x15, 0xff, 0xff, 0xff, 0xff }, 4,  11,   6,	  15,	 0 },	// K9F1G08
+	{ {0xec, 0xf1, 0x00, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   6,	  15,	 0 },	// K9F1G08
+	{ {0xec, 0xda, 0xff, 0x15, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   6,	  15,	 0 },	// K9K2G08
+	{ {0xec, 0xda, 0x10, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   6,	  15,	 0 },	// K9F2G08
+	{ {0xec, 0xdc, 0xc1, 0x15, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   6,	  15,	 0 },	// K9K4G08
+	{ {0xec, 0xdc, 0x10, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   6,	  15,	 0 },	// K9F4G08
+	{ {0xec, 0xd3, 0x51, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   6,	  30,	 0 },	// K9K8G08
+	//----------------------------------------------------------------------------------------------
+	{ {0xec, 0xd3, 0x50, 0xa6, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   7,	  30,	 0 },	// K9F8G08
+	{ {0xec, 0xd5, 0x51, 0xa6, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   7,	  30,	 0 },	// K9KAG08
+	//----------------------------------------------------------------------------------------------
+	{ {0xec, 0xdc, 0x14, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   7,	  20,	 0 },	// K9G4G08
+	{ {0xec, 0xdc, 0x14, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   7,	  30,	 0 },	// K9G4G08
+	{ {0xec, 0xd3, 0x55, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   7,	  20,	 0 },	// K9L8G08
+	{ {0xec, 0xd3, 0x55, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   7,	  30,	 0 },	// K9L8G08
+	{ {0xec, 0xd3, 0x14, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   7,	  20,	 0 },	// K9G8G08
+	{ {0xec, 0xd3, 0x14, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   7,	  30,	 0 },	// K9G8G08
+	{ {0xec, 0xd5, 0x55, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   7,	  30,	 0 },	// K9LAG08
+	{ {0xec, 0xd5, 0x55, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	 11,   7,	  30,	 0 },	// K9LAG08
+	//----------------------------------------------------------------------------------------------
+	{ {0xec, 0xd5, 0x14, 0xb6, 0xff, 0xff, 0xff, 0xff }, 4,	 12,   7,	  30,	 0 },	// K9GAG08
+	{ {0xec, 0xd7, 0x55, 0xb6, 0xff, 0xff, 0xff, 0xff }, 4,	 12,   7,	  30,	 0 },	// K9LBG08
+	{ {0xec, 0xd7, 0xd5, 0x29, 0xff, 0xff, 0xff, 0xff }, 4,	 12,   7,	  30,	 0 },	// K9LBG08
+	{ {0xec, 0xd7, 0x94, 0x72, 0xff, 0xff, 0xff, 0xff }, 4,	 13,   7,	  30,	 2 },	// K9GBG08
+	{ {0xec, 0xd5, 0x98, 0x71, 0xff, 0xff, 0xff, 0xff }, 4,	 12,   8,	  30,	 3 },	// K9AAG08
+																		  
+	{ {0xec, 0xd5, 0x94, 0x29, 0xff, 0xff, 0xff, 0xff }, 4,	 12,   7,	  30,	 0 },	// K9GAG08U0D
+	{ {0xec, 0xd5, 0x84, 0x72, 0xff, 0xff, 0xff, 0xff }, 4,	 13,   7,	  24,	 2 },	// K9GAG08U0E
+	{ {0xec, 0xd5, 0x94, 0x76, 0x54, 0xff, 0xff, 0xff }, 5,	 13,   7,	  30,	 2 },	// K9GAG08U0E
+	{ {0xec, 0xd3, 0x84, 0x72, 0xff, 0xff, 0xff, 0xff }, 4,	 13,   7,	  24,	 2 },	// K9G8G08U0C
+	{ {0xec, 0xd7, 0x94, 0x76, 0xff, 0xff, 0xff, 0xff }, 4,	 13,   7,	  30,	 3 },	// K9GBG08U0A
+	{ {0xec, 0xd7, 0x94, 0x7A, 0xff, 0xff, 0xff, 0xff }, 4,	 13,   7,	  30,	 3 },	// K9GBG08U0A
+	{ {0xec, 0xde, 0xd5, 0x7A, 0x58, 0xff, 0xff, 0xff }, 5,	 13,   7,	  30,	 3 },	 // K9LCG08U0A
+
+	{ {0xec, 0xd7, 0x94, 0x7A, 0x54, 0xc3, 0xff, 0xff }, 6,	 13,   7,	  60,	 1 },	// toogle nand 1.0
+	{ {0xec, 0xde, 0xa4, 0x7a, 0x68, 0xc4, 0xff, 0xff }, 6,	 13,   7,	  60,	 4 },	// toogle nand 2.0 K9GCGD8U0A
+	{ {0xec, 0xd7, 0x94, 0x7E, 0x64, 0xc4, 0xff, 0xff }, 6,	 13,   7,	  60,	 4 },	// toogle nand 2.0 K9GBGD8U0B
+	{ {0xec, 0xd7, 0x94, 0x7e, 0x64, 0x44, 0xff, 0xff }, 6,	 13,   7,	  40,	 4 },	// 21nm sdr K9GBG08U0B
+																		  
+	//---------------------------------------------------------------------------------------------
+	{ {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,	 0,	   0,	  0,     0 },
+};
+
+//==============================================================================
+//============================= HYNIX NAND FLASH ===============================
+//==============================================================================
+static struct nand_chip_param hynix_chip_param[] = {
+	// id id_len page_shift page_per_block_shift clock_freq ecc_mode
+    //-------------------------------------------------------------------------------------------------------------
+	{ {0xad, 0xf1, 0x80, 0x15, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	6,	   15,	   0 },	  // HY27UF081G2M
+	{ {0xad, 0xf1, 0x80, 0x1d, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	6,	   20,	   0 },	  // HY27UF081G2A
+	{ {0xad, 0xf1, 0x00, 0x1d, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	6,	   20,	   0 },	  // H27U1G8F2B
+	{ {0xad, 0xda, 0x80, 0x15, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	6,	   15,	   0 },	  // HY27UF082G2M
+	{ {0xad, 0xda, 0x80, 0x1d, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	6,	   20,	   0 },	  // HY27UF082G2A
+	{ {0xad, 0xda, 0x10, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	6,	   20,	   0 },	  // HY27UF082G2B
+	{ {0xad, 0xdc, 0x80, 0x15, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	6,	   15,	   0 },	  // HY27UH084G2M
+	{ {0xad, 0xdc, 0x80, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	6,	   20,	   0 },	  // HY27UF084G2M, HY27UG088G5M
+	{ {0xad, 0xdc, 0x10, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	6,	   20,	   0 },	  // HY27UF084G2B, HY27UG088G5B
+	{ {0xad, 0xd3, 0x80, 0x15, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	6,	   20,	   0 },	  // HY27UG084G2M, HY27H088G2M
+	{ {0xad, 0xd3, 0xc1, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	6,	   20,	   0 },	  // HY27UG088G2M, HY27UH08AG5M
+	//--------------------------------------------------------------------------------------------------------------
+	{ {0xad, 0xdc, 0x84, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	7,	   12,	   0 },	  // HY27UT084G2M, HY27UU088G5M
+	{ {0xad, 0xdc, 0x14, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	7,	   15,	   0 },	  // HY27U4G8T2BTR
+	{ {0xad, 0xd3, 0x85, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	7,	   10,	   0 },	  // HY27UV08AG5M, HY27UW08BGFM
+	{ {0xad, 0xd3, 0x14, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	7,	   12,	   0 },	  // HY27UT088G2M, HY27UU08AG5M
+	{ {0xad, 0xd3, 0x14, 0x2d, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	7,	   25,	   0 },	  // HY27UT088G2M, HY27UU08AG5M
+	{ {0xad, 0xd3, 0x14, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	7,	   15,	   0 },	  // HY27UT088G2M, HY27UU08AG5M
+	{ {0xad, 0xd5, 0x55, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	7,	   15,	   0 },	  // HY27UV08BG5M, HY27UW08CGFM
+	{ {0xad, 0xd5, 0x55, 0x2d, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	7,	   25,	   0 },	  // HY27UV08BG5M, HY27UW08CGFM
+	{ {0xad, 0xd5, 0x55, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	 11,	7,	   30,	   0 },	  // HY27UV08BG5M, HY27UW08CGFM
+	//--------------------------------------------------------------------------------------------------------------
+	{ {0xad, 0xd3, 0x14, 0xb6, 0xff, 0xff, 0xff, 0xff }, 4,	 12,	7,	   30,	   0 },	  // H27U8G8T2B
+	{ {0xad, 0xd5, 0x14, 0xb6, 0xff, 0xff, 0xff, 0xff }, 4,	 12,	7,	   30,	   0 },	  // H27UAG8T2M, H27UBG8U5M
+	{ {0xad, 0xd7, 0x55, 0xb6, 0xff, 0xff, 0xff, 0xff }, 4,	 12,	7,	   30,	   0 },	  // H27UCG8V5M
+	//--------------------------------------------------------------------------------------------------------------
+	{ {0xad, 0xd5, 0x94, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	 12,	7,	   30,	   2 },	  // H27UBG8U5A
+	{ {0xad, 0xd7, 0x95, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	 12,	7,	   30,	   2 },	  // H27UCG8V5A
+	{ {0xad, 0xd5, 0x95, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	 12,	7,	   30,	   2 },	  // H27UCG8VFA
+	{ {0xad, 0xd5, 0x94, 0x9A, 0xff, 0xff, 0xff, 0xff }, 4,	 13,	8,	   30,	   2 },	  // H27UAG8T2B
+	{ {0xad, 0xd7, 0x94, 0x9A, 0xff, 0xff, 0xff, 0xff }, 4,	 13,	8,	   30,	   2 },	  // H27UBG8T2A H27UCG8U5(D)A H27UDG8VF(D)A
+	{ {0xad, 0xde, 0xd5, 0x9A, 0xff, 0xff, 0xff, 0xff }, 4,	 13,	8,	   30,	   2 },	  // H27UDG8V5A
+	{ {0xad, 0xd7, 0x94, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	 12,	7,	   30,	   2 },	  // H27UBG8T2M
+	{ {0xad, 0xde, 0x94, 0xd2, 0xff, 0xff, 0xff, 0xff }, 4,	 13,	8,	   30,	   2 },	  // H27UCG8T2M
+	{ {0xad, 0xd7, 0x18, 0x8d, 0xff, 0xff, 0xff, 0xff }, 4,	 12,	8,	   30,	   3 },	  // H27UBG8M2A
+	{ {0xad, 0xd7, 0x94, 0xda, 0xff, 0xff, 0xff, 0xff }, 4,	 13,	8,	   30,	   3 },	  // H27UBG8M2A
+	{ {0xad, 0xde, 0x94, 0xda, 0x74, 0xff, 0xff, 0xff }, 5,	 13,	8,	   40,	   4 },	  // H27UCG8T2A
+	{ {0xad, 0xd7, 0x94, 0x91, 0x60, 0xff, 0xff, 0xff }, 5,	 13,	8,	   40,	   4 },	  // H27UBG8T2C
+	//--------------------------------------------------------------------------------------------------------------
+	{ {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,	 0,		0,	   0,	   0 },	  // NULL
+};
+
+
+//==============================================================================
+//============================= TOSHIBA NAND FLASH =============================
+//==============================================================================
+static struct nand_chip_param toshiba_chip_param[] = {
+	// id id_len page_shift page_per_block_shift clock_freq ecc_mode
+    //--------------------------------------------------------------------------------------------------------------------
+	{ {0x98, 0xf1, 0x80, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,	  20,	  0 },	 // TC58NVG0S3B
+	{ {0x98, 0xda, 0xff, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,	  20,	  0 },	 // TC58NVG1S3B
+	{ {0x98, 0xdc, 0x81, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,	  20,	  0 },	 // TC58NVG2S3B
+	{ {0x98, 0xd1, 0x90, 0x15, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,	  20,	  0 },	 // TC58NVG0S3E
+	//--------------------------------------------------------------------------------------------------------------------
+	{ {0x98, 0xda, 0x84, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 7,	  20,	  0 },	 // TC58NVG1D4B
+	{ {0x98, 0xdc, 0x84, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 7,	  20,	  0 },	 // TC58NVG2D4B
+	{ {0x98, 0xd3, 0x84, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 7,	  20,	  0 },   // TC58NVG3D4C
+	{ {0x98, 0xd5, 0x85, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 7,	  20,	  0 },   // TC58NVG4D4C, TC58NVG5D4C
+	//--------------------------------------------------------------------------------------------------------------------
+	{ {0x98, 0xd3, 0x94, 0xba, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 7,	  20,	  0 },   // TC58NVG3D1DTG00
+	{ {0x98, 0xd7, 0x95, 0xba, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 7,	  30,	  2 },   // TC58NVG6D1DTG20
+	{ {0x98, 0xd5, 0x94, 0xba, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 7,	  30,	  2 },   // TH58NVG5D1DTG20
+	{ {0x98, 0xd5, 0x94, 0x32, 0xff, 0xff, 0xff, 0xff }, 4,	  13,	 7,	  25,	  1 },   // TH58NVG4D2ETA20 TH58NVG4D2FTA20 TH58NVG5D2ETA00
+	{ {0x98, 0xd7, 0x94, 0x32, 0xff, 0xff, 0xff, 0xff }, 4,	  13,	 7,	  25,	  2 },   // TH58NVG5D2FTA00 TH58NVG6D2FTA20
+	{ {0x98, 0xd7, 0x95, 0x32, 0xff, 0xff, 0xff, 0xff }, 4,	  13,	 7,	  25,	  1 },   // TH58NVG6D2ETA20
+	//--------------------------------------------------------------------------------------------------------------------
+	{ {0x98, 0xde, 0x94, 0x82, 0x76, 0xff, 0xff, 0xff }, 5,	  13,	 8,	  40,	  4 },   // TH58NVG6D2ETA20
+	{ {0x98, 0xd7, 0x94, 0x32, 0x76, 0x56, 0xff, 0xff }, 6,	  13,	 7,	  40,	  4 },   // TH58NVG5D2HTA20
+	{ {0x98, 0xd5, 0x84, 0x32, 0x72, 0x56, 0xff, 0xff }, 6,	  13,	 7,	  40,	  4 },   // TH58NVG4D2HTA20
+	//--------------------------------------------------------------------------------------------------------------------
+	{ {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,	  0,	 0,	  0,	  0 },   // NULL
+};
+
+
+//==============================================================================
+//============================= MICON NAND FLASH ===============================
+//==============================================================================
+static struct nand_chip_param micron_chip_param[] = {
+	// id id_len page_shift page_per_block_shift clock_freq ecc_mode
+    //---------------------------------------------------------------------------------------------------------------------------------------
+	{ {0x2c, 0xda, 0xff, 0x15, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,		25,		0 },	 // MT29F2G08AAC, JS29F02G08AAN
+	{ {0x2c, 0xdc, 0xff, 0x15, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,		25,		0 },	 // MT29F4G08BAB, MT29F8G08FAB, JS29F04G08BAN, JS29F08G08FAN
+	{ {0x2c, 0xdc, 0x90, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,		25,		0 },	 // MT29F4G08AAA, MT29F8G08DAA, JS29F04G08AAN
+	{ {0x2c, 0xd3, 0xd1, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,		25,		0 },	 // MT29F8G08BAB, MT29F16G08FAB, JS29F08G08BAN, JS29F16G08FAN
+	//---------------------------------------------------------------------------------------------------------------------------------------
+	{ {0x2c, 0xdc, 0x84, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 7,		20,		0 },	 // MT29F4G08MAA, MT29F8G08QAA
+	{ {0x2c, 0xd3, 0x85, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 7,		20,		0 },	 // MT29F16GTAA
+	{ {0x2c, 0xd3, 0x94, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 7,		30,		0 },	 // MT29F8G08MAA, MT29F16G08QAA, JS29F08G08AAM, JS29F16G08CAM
+	{ {0x2c, 0xd5, 0x95, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 7,		20,		0 },	 // MT29F32G08TAA, JS29F32G08FAM
+	{ {0x2c, 0xd5, 0xd5, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 7,		20,		0 },	 // MT29F32G08TAA, JS29F32G08FAM
+	//---------------------------------------------------------------------------------------------------------------------------------------
+	{ {0x2c, 0xd5, 0x94, 0x3e, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 7,		30,		0 },	 // MT29F16G08MAA, MT29F32G08QAA, JS29F32G08AAM, JS29F32G08CAM
+	{ {0x2c, 0xd5, 0xd5, 0x3e, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 7,		30,		0 },	 // MT29F64G08TAA, JS29F64G08FAM
+	//---------------------------------------------------------------------------------------------------------------------------------------
+	{ {0x2c, 0xd7, 0x94, 0x3e, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 7,		30,		2 },	 // MT29F32G08CBAAA,MT29F64G08CFAAA
+	{ {0x2c, 0xd7, 0xd5, 0x3e, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 7,		30,		2 },	 // MT29F64G08CTAA
+	{ {0x2c, 0xd9, 0xd5, 0x3e, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 7,		30,		2 },	 // MT29F128G08,
+	{ {0x2c, 0x68, 0x04, 0x46, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 8,		30,		2 },	 // MT29F32G08CBABA
+	{ {0x2c, 0x88, 0x05, 0xC6, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 8,		30,		2 },	 // MT29F128G08CJABA
+	{ {0x2c, 0x88, 0x04, 0x4B, 0xff, 0xff, 0xff, 0xff }, 4,	  13,	 8,		40,		2 },	 // MT29F64G08CBAAA
+	{ {0x2c, 0x68, 0x04, 0x4A, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 8,		40,		2 },	 // MT29F32G08CBACA
+	{ {0x2c, 0x48, 0x04, 0x4A, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 8,		40,		2 },	 // MT29F16G08CBACA
+	{ {0x2c, 0x48, 0x04, 0x46, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 8,		30,		2 },	 // MT29F16G08CBABA
+	{ {0x2c, 0x64, 0x44, 0x4B, 0xA9, 0xff, 0xff, 0xff }, 5,	  13,	 8,		40,		4 },	 // MT29F64G08CBABA
+	//---------------------------------------------------------------------------------------------------------------------------------------
+	{ {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,	  0,	 0,     0,      0 },     // NULL
+};
+
+
+//==============================================================================
+//============================= INTEL NAND FLASH ===============================
+//==============================================================================
+static struct nand_chip_param intel_chip_param[] = {
+	// id id_len page_shift page_per_block_shift clock_freq ecc_mode
+    //---------------------------------------------------------------------------------------------------------------------------
+	{ {0x89, 0xd3, 0x94, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 7,		30,		0 },	 // 29F08G08AAMB2, 29F16G08CAMB2
+	{ {0x89, 0xd5, 0xd5, 0xa5, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 7,		20,		0 },	 // 29F32G08FAMB2
+	//---------------------------------------------------------------------------------------------------------------------------
+	{ {0x89, 0xd7, 0x94, 0x3e, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 7,		30,		2 },	 // MLC32GW8IMA,MLC64GW8IMA, 29F32G08AAMD2, 29F64G08CAMD2
+	{ {0x89, 0xd5, 0x94, 0x3e, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 7,		30,		2 },	 // 29F32G08CAMC1
+	{ {0x89, 0xd7, 0xd5, 0x3e, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 7,		30,		2 },	 // 29F64G08FAMC1
+	{ {0x89, 0x68, 0x04, 0x46, 0xff, 0xff, 0xff, 0xff }, 4,	  12,	 8,		30,		2 },	 // 29F32G08AAMDB
+	{ {0x89, 0x88, 0x24, 0x4B, 0xff, 0xff, 0xff, 0xff }, 4,	  13,	 8,		30,		2 },	 //	29F64G08CBAAA 29F64G083AME1
+	{ {0x89, 0xA8, 0x25, 0xCB, 0xff, 0xff, 0xff, 0xff }, 4,	  13,	 8,		30,		2 },	 //	29F64G08CBAAA 29F64G083AME1
+	//---------------------------------------------------------------------------------------------------------------------------
+	{ {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,	  0,	 0,		0,	    0 },   // NULL
+};
+
+
+//==============================================================================
+//=============================== ST NAND FLASH ================================
+//==============================================================================
+static struct nand_chip_param st_chip_param[] = {
+	// id id_len page_shift page_per_block_shift clock_freq ecc_mode
+    //------------------------------------------------------------------------------------------------------
+	{ {0x20, 0xf1, 0x80, 0x15, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,		15,		0 },  // NAND01GW3B
+	{ {0x20, 0xf1, 0x00, 0x1d, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,		15,		0 },  // NAND01G001
+	{ {0x20, 0xda, 0x80, 0x15, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,		15,		0 },  // NAND02GW3B
+	{ {0x20, 0xda, 0x10, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,		15,		0 },  // NAND02GW3B2DN6
+	{ {0x20, 0xdc, 0x80, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,		15,		0 },  // NAND04GW3B
+	{ {0x20, 0xd3, 0xc1, 0x95, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,		15,		0 },  // NAND08GW3B
+	//------------------------------------------------------------------------------------------------------
+	{ {0x20, 0xdc, 0x84, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 7,		15,		0 },  // NAND04GW3C
+	{ {0x20, 0xd3, 0x85, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 7,		15,		0 },  // NAND08GW3C
+	{ {0x20, 0xd3, 0x85, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 7,		15,		0 },  // NAND16GW3C
+	//------------------------------------------------------------------------------------------------------
+	{ {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,	  0,	 0,		0,	    0 },  // NULL
+};
+
+//==============================================================================
+//============================ SPANSION NAND FLASH ==============================
+//==============================================================================
+static struct nand_chip_param spansion_chip_param[] = {
+	// id id_len page_shift page_per_block_shift clock_freq ecc_mode
+    //-------------------------------------------------------------------------------------------------------
+	{ {0x01, 0xaa, 0x10, 0x00, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,		30,		0 },	 // S39MS02G
+	{ {0x01, 0xa1, 0x10, 0x00, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,		30,		0 },	 // S39MS01G
+	{ {0x01, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff }, 4,	  11,	 6,		30,		0 },	 // DFT01GR08P1PM0
+	//-------------------------------------------------------------------------------------------------------
+	{ {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,	  0,	 0,		0,		0 },	 // NULL
+};
+
+//==============================================================================
+//============================ POWER NAND FLASH ==============================
+//==============================================================================
+static struct nand_chip_param power_chip_param[] = {
+	// id id_len page_shift page_per_block_shift clock_freq ecc_mode
+    //--------------------------------------------------------------------------------------------------
+	{ {0x92, 0xf1, 0x80, 0x95, 0x40, 0xff, 0xff, 0xff }, 5,	  11,	 6,	    30,	    0 },	 // ASU1GA
+	//--------------------------------------------------------------------------------------------------
+	{ {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,	  0,	 0,     0,      0 },     // NULL
+};
+
+static struct nand_chip_param default_chip_param[] = {
+	//--------------------------------------------------------------------------------------------------
+    { {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,   0,     0,     0,      0 },     // NULL
+};
+
+struct nand_chip_param *sunxi_get_nand_chip_param(unsigned char mf)
+{
+	switch (mf) {
+	case 0xec:
+		return samsung_chip_param;
+	case 0xad:
+		return hynix_chip_param;
+	case 0x98:
+		return toshiba_chip_param;
+	case 0x2c:
+		return micron_chip_param;
+	case 0x89:
+		return intel_chip_param;
+	case 0x20:
+		return st_chip_param;
+	case 0x01:
+		return spansion_chip_param;
+	case 0x92:
+		return power_chip_param;
+	default:
+		return default_chip_param;
+	}
+}
+
diff --git a/drivers/mtd/nand/sunxi_nand_spl.c b/drivers/mtd/nand/sunxi_nand_spl.c
new file mode 100644
index 0000000..48e08c2
--- /dev/null
+++ b/drivers/mtd/nand/sunxi_nand_spl.c
@@ -0,0 +1,288 @@
+/*
+ * sunxi_nand_spl.c
+ *
+ * Copyright (C) 2013 Qiang Yu <yuq825@gmail.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "sunxi_nand.h"
+
+int sunxi_nand_spl_page_size;
+int sunxi_nand_spl_block_size;
+
+static int nfc_isbad(uint32_t offs)
+{
+	uint32_t page_addr;
+	uint32_t cfg = NAND_CMD_READ0 | NFC_SEQ | NFC_SEND_CMD1 | NFC_DATA_TRANS | NFC_SEND_ADR | 
+		NFC_SEND_CMD2 | ((5 - 1) << 16) | NFC_WAIT_FLAG | (0 << 30);
+
+	offs &= ~(sunxi_nand_spl_block_size - 1);
+	page_addr = offs / sunxi_nand_spl_page_size;
+
+	wait_cmdfifo_free();
+	writel(readl(NFC_REG_CTL) & ~NFC_RAM_METHOD, NFC_REG_CTL);
+	writel(sunxi_nand_spl_page_size | (page_addr << 16), NFC_REG_ADDR_LOW);
+	writel(page_addr >> 16, NFC_REG_ADDR_HIGH);
+	writel(2, NFC_REG_CNT);
+	writel(1, NFC_REG_SECTOR_NUM);
+	writel(NAND_CMD_READSTART, NFC_REG_RCMD_SET);
+	writel(cfg, NFC_REG_CMD);
+	wait_cmdfifo_free();
+	wait_cmd_finish();
+	if (readb(NFC_RAM0_BASE) != 0xff)
+		return 1;
+	return 0;
+}
+
+static void nfc_read_page(uint32_t offs, void *buff)
+{
+	uint32_t page_addr;
+	uint32_t cfg = NAND_CMD_READ0 | NFC_SEND_CMD2 | NFC_DATA_SWAP_METHOD | NFC_SEND_CMD1 |
+		NFC_SEND_ADR | ((5 - 1) << 16) | NFC_WAIT_FLAG | NFC_DATA_TRANS | (2 << 30);
+
+	page_addr = offs / sunxi_nand_spl_page_size;
+
+	wait_cmdfifo_free();
+	writel(readl(NFC_REG_CTL) | NFC_RAM_METHOD, NFC_REG_CTL);
+	_dma_config_start(0, NFC_REG_IO_DATA, (__u32)buff, sunxi_nand_spl_page_size);
+	writel(page_addr << 16, NFC_REG_ADDR_LOW);
+	writel(page_addr >> 16, NFC_REG_ADDR_HIGH);
+	writel(0x00e00530, NFC_REG_RCMD_SET);
+	writel(1024, NFC_REG_CNT);
+	writel(sunxi_nand_spl_page_size / 1024, NFC_REG_SECTOR_NUM);
+	enable_ecc(1);
+	writel(cfg, NFC_REG_CMD);
+	_wait_dma_end();
+	wait_cmdfifo_free();
+	wait_cmd_finish();
+	disable_ecc();
+	if (check_ecc(sunxi_nand_spl_page_size / 1024) < 0)
+		error("can't correct bit error of page read at offset %x\n", offs);
+}
+
+static void nfc_reset(void)
+{
+	u32 cfg;
+
+	wait_cmdfifo_free();
+	cfg = NAND_CMD_RESET | NFC_SEND_CMD1;
+	writel(cfg, NFC_REG_CMD);
+	wait_cmdfifo_free();
+	wait_cmd_finish();
+	// wait rb0 ready
+	select_rb(0);
+	while (!check_rb_ready(0));
+	// wait rb1 ready
+	select_rb(1);
+	while (!check_rb_ready(1));
+	// select rb 0 back
+	select_rb(0);
+}
+
+static void nfc_readid(uint8_t *id)
+{
+	u32 cfg;
+	int i;
+
+	wait_cmdfifo_free();
+	writel(0, NFC_REG_ADDR_LOW);
+	writel(0, NFC_REG_ADDR_HIGH);
+	cfg = NAND_CMD_READID | NFC_SEND_ADR | NFC_DATA_TRANS | NFC_SEND_CMD1;
+	writel(8, NFC_REG_CNT);
+	writel(cfg, NFC_REG_CMD);
+	wait_cmdfifo_free();
+	wait_cmd_finish();
+
+	for (i = 0; i < 8; i++)
+		id[i] = readb(NFC_RAM0_BASE + i);
+}
+
+static void nfc_select_chip(int chip)
+{
+	uint32_t ctl;
+	// A10 has 8 CE pin to support 8 flash chips
+    ctl = readl(NFC_REG_CTL);
+    ctl &= ~NFC_CE_SEL;
+	ctl |= ((chip & 7) << 24);
+    writel(ctl, NFC_REG_CTL);
+}
+
+static int nfc_init(void)
+{
+	u32 ctl;
+	int i, j;
+	uint8_t id[8];
+	struct nand_chip_param *nand_chip_param, *chip_param = NULL;
+
+	debug("board_nand_init start\n");
+
+	// set init clock
+	sunxi_nand_set_clock(NAND_MAX_CLOCK);
+
+	// set gpio
+	sunxi_nand_set_gpio();
+
+	// reset NFC
+	ctl = readl(NFC_REG_CTL);
+	ctl |= NFC_RESET;
+	writel(ctl, NFC_REG_CTL);
+	while(readl(NFC_REG_CTL) & NFC_RESET);
+
+	// enable NFC
+	ctl = NFC_EN;
+	writel(ctl, NFC_REG_CTL);
+
+	// serial_access_mode = 1
+	ctl = (1 << 8);
+	writel(ctl, NFC_REG_TIMING_CTL);
+
+	// reset nand chip
+	nfc_reset();
+
+	// read nand chip id
+	nfc_readid(id);
+
+	// find chip
+	nand_chip_param = sunxi_get_nand_chip_param(id[0]);
+	for (i = 0; nand_chip_param[i].id_len; i++) {
+		int find = 1;
+		for (j = 0; j < nand_chip_param[i].id_len; j++) {
+			if (id[j] != nand_chip_param[i].id[j]) {
+				find = 0;
+				break;
+			}
+		}
+		if (find) {
+			chip_param = &nand_chip_param[i];
+			debug("find nand chip in sunxi database\n");
+			break;
+		}
+	}
+
+	// not find
+	if (chip_param == NULL) {
+		error("can't find nand chip in sunxi database\n");
+		return -ENODEV;
+	}
+
+	// set final NFC clock freq
+	if (chip_param->clock_freq > 30)
+		chip_param->clock_freq = 30;
+	sunxi_nand_set_clock((int)chip_param->clock_freq * 1000000);
+	debug("set final clock freq to %dMHz\n", (int)chip_param->clock_freq);
+
+	// disable interrupt
+	writel(0, NFC_REG_INT);
+	// clear interrupt
+	writel(readl(NFC_REG_ST), NFC_REG_ST);
+
+	// set ECC mode
+	ctl = readl(NFC_REG_ECC_CTL);
+	ctl &= ~NFC_ECC_MODE;
+	ctl |= (unsigned int)chip_param->ecc_mode << NFC_ECC_MODE_SHIFT;
+	writel(ctl, NFC_REG_ECC_CTL);
+
+	// enable NFC
+	ctl = NFC_EN;
+
+	// Page size
+	if (chip_param->page_shift > 14 || chip_param->page_shift < 10) {
+		error("Flash chip page shift out of range %d\n", chip_param->page_shift);
+		return -EINVAL;
+	}
+	// 0 for 1K
+	ctl |= ((chip_param->page_shift - 10) & 0xf) << 8;
+	writel(ctl, NFC_REG_CTL);
+
+	writel(0xff, NFC_REG_TIMING_CFG);
+	writel(1U << chip_param->page_shift, NFC_REG_SPARE_AREA);
+
+	// disable random
+	disable_random();
+
+	// record size
+	sunxi_nand_spl_page_size = 1U << chip_param->page_shift;
+	sunxi_nand_spl_block_size = 1U << (chip_param->page_per_block_shift + chip_param->page_shift);
+
+	// setup DMA
+	dma_hdle = DMA_Request(DMAC_DMATYPE_DEDICATED);
+	if (dma_hdle == 0) {
+		error("request DMA fail\n");
+		return -ENODEV;
+	}
+
+	debug("board_nand_init finish\n");
+
+	return 0;
+}
+
+int nand_spl_isbad(uint32_t offs)
+{
+	return nfc_isbad(offs);
+}
+
+void nand_spl_read(uint32_t offs, int size, void *dst)
+{
+	// offs must be page aligned
+	while (size > 0) {
+		nfc_read_page(offs, dst);
+		offs += sunxi_nand_spl_page_size;
+		dst += sunxi_nand_spl_page_size;
+		size -= sunxi_nand_spl_page_size;
+	}
+}
+
+int nand_spl_load_image(uint32_t offs, unsigned int image_size, void *dst)
+{
+	int size = image_size;
+	uint32_t to, len, bound;
+
+	debug("nand spl load image from %x to %x size %x\n", offs, dst, size);
+
+	while (size > 0) {
+		if (nand_spl_isbad(offs)) {
+			debug("nand spl block %x is bad\n", offs);
+			offs += sunxi_nand_spl_block_size;
+			continue;
+		}
+			
+		to = roundup(offs, sunxi_nand_spl_block_size);
+		bound = (to == offs) ? sunxi_nand_spl_block_size : (to - offs);
+		len = bound > size ? size : bound;
+		nand_spl_read(offs, len, dst);
+		offs += len;
+		dst += len;
+		size -= len;
+	}
+
+	return 0;
+}
+
+/* nand_init() - initialize data to make nand usable by SPL */
+void nand_init(void)
+{
+	if (nfc_init())
+		return;
+
+	nfc_select_chip(0);
+}
+
+/* Unselect after operation */
+void nand_deselect(void)
+{
+
+}
+
+
diff --git a/include/configs/sunxi-common.h b/include/configs/sunxi-common.h
index 8ab6429..9edeec6 100644
--- a/include/configs/sunxi-common.h
+++ b/include/configs/sunxi-common.h
@@ -64,6 +64,42 @@
 #define CONFIG_CMDLINE_TAG
 #define CONFIG_INITRD_TAG
 
+#ifdef CONFIG_NAND
+
+#define CONFIG_LIB_RAND
+
+#define CONFIG_NAND_SUNXI		1
+
+#define CONFIG_CMD_NAND
+#define CONFIG_SYS_MAX_NAND_DEVICE      1
+#define CONFIG_SYS_NAND_BASE            0
+#define CONFIG_SUNXI_DMA
+
+#define CONFIG_RBTREE
+#define CONFIG_LZO
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_CMD_UBI
+#define CONFIG_CMD_UBIFS
+#define CONFIG_CMD_NAND_1K
+
+#define CONFIG_ENV_IS_IN_NAND
+
+#define CONFIG_ENV_OFFSET	0x500000	/* at 5MB */
+#define CONFIG_ENV_RANGE        0x300000
+
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_NAND_ECC
+#define CONFIG_SPL_NAND_BASE
+#define CONFIG_SPL_NAND_DRIVERS
+#define CONFIG_SPL_DMA_SUPPORT
+#define CONFIG_SYS_NAND_U_BOOT_OFFS     0x200000
+
+#define CONFIG_SYS_NAND_PAGE_SIZE sunxi_nand_spl_page_size
+#define CONFIG_SYS_NAND_BLOCK_SIZE sunxi_nand_spl_block_size
+#endif
+
 /* mmc config */
 #define CONFIG_MMC
 #define CONFIG_GENERIC_MMC
@@ -73,8 +109,8 @@
 #define CONFIG_ENV_IS_IN_MMC
 #define CONFIG_SYS_MMC_ENV_DEV		0	/* first detected MMC controller */
 
-/* 4MB of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (4 << 20))
+/* 16MB of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (16 << 20))
 
 /*
  * Miscellaneous configurable options
@@ -140,14 +176,8 @@
 #define CONFIG_SPL_TEXT_BASE		0x20		/* sram start+header */
 #define CONFIG_SPL_MAX_SIZE		0x5fe0		/* 24KB on sun4i/sun7i */
 
-#define CONFIG_SPL_LIBDISK_SUPPORT
-#define CONFIG_SPL_MMC_SUPPORT
-
 #define CONFIG_SPL_LDSCRIPT "arch/arm/cpu/armv7/sunxi/u-boot-spl.lds"
 
-#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR	80	/* 40KiB */
-#define CONFIG_SPL_PAD_TO		32768		/* decimal for 'dd' */
-
 #endif /* CONFIG_SPL */
 
 /* end of 32 KiB in sram */
-- 
1.9.0

